<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_snc_dk_validator.Inspector</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <name>Inspector</name>
        <script><![CDATA[//
// The Inspector Class can examine the following record classes - 
//      - Application File descendents
//      - wf_activty
//      - sys_variable_value
//
// It will take inventory of both record and script metrics 
//

var Inspector = Class.create();
Inspector.prototype = {
    initialize: function () {
    },

    type: 'Inspector'
};

Inspector.InstanceName = gs.getProperty("instance_name");

// Take inventory of an Application File descendent
// 
// Caller must ensure that 
//      - The GlideRecord is an Application File descendent 
//      - The GlideRecord is active and under inspection, i.e.
//          - Inspector.isRecordUnderInspection(gr, ...) returns true 
//          - Inspector.isActive(gr) is true
// 
// This method will update various metrics based on the record class (table), 
// and scan scripts for script metrics, if any exist.
//
// If this is a scan of a packaged artifacts (update sets, pluggins, scopes), it will
// also log all scripted library methods found for subsequent ATF execution 
// analysis.
Inspector.examineRecord = function (stats, state, gr, class_name, name_field, api, isPackageScan) {
    // gr must be an Application File or descendent

    try {

        // Artifical Class Name tracking
        // Look for a global Business Rule. Needs to be treaded like a Script Include
        if (gr.sys_class_name == "sys_script" && gr.collection == "global") {
            class_name = "sys_script_global"; // This is a special class injected into the app file spider
        }

        if (isPackageScan) {
            Inspector.logTargets(state, class_name, gr.sys_id.toString(), api);
        }

        Inspector.initializeInventoryLog(stats, state, class_name);

        // A parameter into the AST walk basically, since we count code in there
        state.stats.inventoryIndex = class_name;

        stats.inventory[class_name].count++;

        if (!gr.sys_scope || gr.sys_scope == "global") {
            stats.inventory[class_name].global_count++;
            state.currentScope = "global";
        }
        else {
            state.currentScope = gr.sys_scope.toString();
        }

        if (Spider.appFiles[class_name].has_script) {

            // Get script fields in this application file
            var scriptFields = Spider.appFiles[class_name].script_fields;
            if (!scriptFields) {
                // This app file doesn't have any scripts
                gs.error("Script fields for " + class_name + " not constructed properly!");
                return;
            }

            // AST walk handlers needed for script scans
            var scriptHandlers = {
                FunctionDeclaration: Scanner.statementHandler,
                FunctionExpression: Scanner.statementHandler,
                CallExpression: Scanner.callExpressionHandler,
                AssignmentExpression: Scanner.assignmentExpressionHandler,
                MemberExpression: Scanner.memberExpressionHandler,
                VariableDeclarator: Scanner.variableDeclaratorHandler,
                ExpressionStatement: Scanner.statementHandler,
                BlockStatement: Scanner.statementHandler,
                IfStatement: Scanner.statementHandler,
                LabeledStatement: Scanner.statementHandler,
                BreakStatement: Scanner.statementHandler,
                ContinueStatement: Scanner.statementHandler,
                WithStatement: Scanner.statementHandler,
                SwitchStatement: Scanner.statementHandler,
                ReturnStatement: Scanner.statementHandler,
                ThrowStatement: Scanner.statementHandler,
                TryStatement: Scanner.tryStatementHandler,
                WhileStatement: Scanner.statementHandler,
                DoWhileStatement: Scanner.statementHandler,
                ForStatement: Scanner.statementHandler,
                ForOfStatement: Scanner.statementHandler,
                LetStatement: Scanner.statementHandler,
                DebuggerStatement: Scanner.statementHandler
            };

            // Script Includes and global business rules have library methods that can be called from
            // other scripts, and tested via ATF. These handlers will keep track of those library methods
            // Note that the business rule "global" is not its scope, but rather it's "table" assignment.
            // Global means it has no specific table. It is always available for execution, i.e. a
            // library method.
            if (isPackageScan && (class_name == "sys_script_include" || class_name == "sys_script_global")) {
                scriptHandlers.FunctionDeclaration = Scanner.functionDeclarationHandler;
                scriptHandlers.FunctionExpression = Scanner.functionExpressionHandler;
            }

            // Since we are here in this block, this record has one or more fields of script type. 
            // Want to make sure there actually is script in at least one field, other than comments.
            // That is what we are tracking. The number of application files with 
            // executable script 
            state.has_script = false;

            for (var field in scriptFields) {

                if (scriptFields[field] != "script" && scriptFields[field] != "script_plain")
                    continue; // only processing these right now

                var script_string = gr[field].toString(); // To be under inspection, must be a script
                if (!script_string)
                    continue;

                //
                // Special handling of scripts in a "partial" format (something must be added
                // in order to be parsed properly)
                //

                // Need to filter out processing of scripts that are not active, expecially
                // given the fact that many scripts have default script and comments that should
                // not be counted
                if ("sys_dictionary" == class_name && "calculation" == field && !gr.virtual) { // DAK
                    continue;
                }
                else if ("metric_definition" == class_name && gr.type != "calculation") {
                    // If not calculation, this is no code field duration
                    continue;
                }
                else if ("sys_ui_policy" == class_name && !gr.run_scripts) {
                    // Normally no code in UI Policy
                    continue;
                }
                else if ("sys_transform_entry" == class_name && !gr.use_source_script) {
                    continue;
                }
                else if ("sys_transform_map" == class_name && !gr.run_script) {
                    continue;
                }


                // All of these begin with an anonymous function, i.e
                // function() {...}
                // They need a prefix, i.e. var X = function() {...}, to make 
                // the parser happy.
                // This may NOT be a complete list! TODO - go through and find all script fields
                // that have this format
                if (class_name == "sp_widget" || class_name == "sp_header_footer" ||
                    class_name == "discovery_sensor_probe_conditional" ||
                    class_name == "ecc_agent_capability_value_test") {
                    if (field == "client_script" || field == "link" || field == "condition_script") {
                        script_string = "var X = " + script_string;
                    }
                }
                else if (class_name == "sp_angular_provider" ||
                    class_name == "discovery_port_probe" ||
                    class_name == "discovery_sensor_multi_probe" ||
                    class_name == "ci_identifier") {
                    if (field == "script") {
                        script_string = "var X = " + script_string;
                    }
                }

                var record_name = class_name + "::" + gr[name_field].toString() + ":" + field;

                Inspector.scanScript(state, stats, script_string, record_name, scriptHandlers);

            }
            if (state.has_script == true) {
                stats.inventory[class_name].scripted_count++;
            }
        }
    }
    catch (e) {
        gs.error("Inspector.examineRecord exception for " + class_name + "::" + gr[name_field] + ". Msg: " + e);
    }
};


Inspector.examinePayload = function (xml_name, target_name, stats, state, payload) {
    // Payload must be for an Application File or descendent
    // This will only be called if we are scanning packages (update sets or pluggins)

    try {

        var payloadXML = new XMLDocument2();
        payloadXML.parseXML(payload);

        // Get the class name (table name)
        // Can be an attribute. Always will be first child of top node
        var class_name = payloadXML.getNode("/record_update").getAttribute("table");

        if (class_name == "") {
            class_name = payloadXML.getNode("/record_update").getFirstChild().getNodeName();
            if (class_name == "") {
                gs.error("examinePayload: Can't find class name, aorting!");
                return;
            }
        }



        if (class_name == "sys_choice") {
            // Choice is a special case!
            // This isn't an app file, but it packaged with an app file - sys_choice_set
            // Change the class over to sys_choice_set
            class_name = "sys_choice_set";

            //
            // Duplicate Visit Check
            // Abort if we have already checked these choices
            // This logic is different than the other installation checks in the else 
            //
            var setId = payloadXML.getNodeText("/record_update/sys_choice/sys_choice_set/sys_id");
            if (state.visitLog.choiceSets[setId]) {
                return;
            }
            state.visitLog.choiceSets[setId] = true;


            // 
            // Track the "state" choices for subsequent test coverage analysis.
            // Because of how choices are managed in update sets, the only practical
            // way to get the choices is go to the installed sys_choice records themselves
            // 

            var currentNode = payloadXML.getNode("/record_update/sys_choice");
            if ("state" == currentNode.getAttribute("field")) {

                var targetTableName = currentNode.getAttribute("table");
                if (!this.targets.states[targetTableName]) {
                    this.targets.states[targetTableName] = {};
                }

                var choicesGR = new GlideRecord("sys_choice");
                choicesGR.addQuery("name", targetTableName);
                choicesGR.addQuery("element", "state");
                choicesGR.query();
                while (choicesGR.next()) {
                    // Initialize what will be the test coverage counter to 0
                    this.targets.states[targetTableName][choicesGR.value.toString()] = 0;
                }
            }
        }

        // Because things aren't always consistent in the XML layout,
        // or we may create an artificial class name (for global business rules)
        // we have to adjust class names for certain application files 
        // The "real_class_name" is what we parse in the update set payload XML
        // We also need to declare the GlideRecord we are going to use to 
        // determine what is installed now, before we make any "artificial" changes
        var real_class_name = class_name;
        var installedGR = new GlideRecord(class_name); // Will be used in a bit

        if (class_name == "sys_script") {
            // Artifical Class Name tracking
            // Look for a global Business Rule. Needs to be treated like a Script Include
            if ("global" == payloadXML.getNodeText("/record_update/sys_script/collection")) {
                class_name = "sys_script_global"; // This is a special class injected into the app file spider
            }
        }

        Inspector.initializeInventoryLog(stats, state, class_name);


        if ("Custom" == stats.inventory[class_name].type) {
            // This is an unknown file class 

            // TODO Open up it's dictionary, and look for scripts to process
            // TODO Perhaps also look for strings that have javascript in them, to 
            // see if someone is trying to cheat
            // For now, we simply record the fact that it exists 

        }
        else {
            // This is an Application File

            // Special Cases
            // For the following classes, there are extra levels we must go down into to find
            // the information we need... 
            //  - sys_documentation
            //  - sys_ui_list
            //  - sys_choice
            //  - sys_ui_section 
            // e.g. for Labels: /record_upate/sys_documenation/sys_documentation/<attributes>
            if (class_name == "sys_documentation" ||
                class_name == "sys_ui_list" ||
                class_name == "sys_ui_section") {
                real_class_name = real_class_name + "/" + real_class_name;
            }
            else if (class_name == "sys_choice_set") {
                // This is the oddball - update set XML comes in as sys_choice, which is not
                // an app file. All the choices in the payload are sys_choice/sys_choice/<...>
                // The sets in that update set XML record are all the choices for a single
                // field in a table. This info is in the sys_choice/sys_choice_set stanza.
                // The set is an app file.
                real_class_name = "sys_choice/sys_choice_set";
            }

            var sys_id = payloadXML.getNodeText("/record_update/" + real_class_name + "/sys_id");

            // Installation Check!
            // This will ensure that we are processing the update set that was 
            // actually installed, and that we don't double count anything 
            // 
            // Note that we don't have to do this for the oddball, sys_choice
            // 
            // What actually is installed,in the event that multiple updates touch the same 
            // application file, is actually quite complex (not just a simple "who came last" 
            // thing), so we are just going to go to the source of truth: what is installed.
            // If this update is installed, process. If not, skip it. 
            if (class_name != "sys_choice_set") {

                if (state.visitLog.appFiles[sys_id]) {
                    return;
                }

                var updated_on = payloadXML.getNodeText("/record_update/" + real_class_name + "/sys_updated_on");
                installedGR.addQuery("sys_id", sys_id);
                installedGR.addQuery("sys_updated_on", updated_on);
                installedGR.query();
                if (!installedGR.hasNext()) {
                    return; // Abort, abort, abort ... this is not installed!
                }

                state.visitLog.appFiles[sys_id] = true;
            }


            stats.inventory[class_name].count++;
            // A parameter into the AST walk basically, since we count code in there
            state.stats.inventoryIndex = class_name;

            var scope = payloadXML.getNodeText("/record_update/" + real_class_name + "/sys_scope");

            if (!scope || scope == "global") {
                stats.inventory[class_name].global_count++;
                state.currentScope = "global";
            }
            else {
                state.currentScope = scope;
            }

            // 
            // I turned this "disabled" check off. Just because they disabled the code,
            // doesn't mean they won't reenable it later. So we want to track 
            // this. 

            //if (Spider.appFiles[class_name].has_active_field) {
            // This is an "Active" record. Can be enabled or disabled.

            // If disabled, don't process its scripts
            //if ("true" != payloadXML.getNodeText("/record_update/" + real_class_name + "/active"))
            //    return;

            //}
            // At this point we have the payload of an enabled "Active" record, or a "Passive" record,
            // which can't be disabled, so continue on ...

            var api_name = payloadXML.getNodeText("/record_update/" + real_class_name + "/api_name");
            Inspector.logTargets(state, class_name, sys_id, api_name);

            //
            // OOTB update detector!
            //
            var thisIsChangeToOOTB = false;
            var update_name = payloadXML.getNodeText("/record_update/" + real_class_name + "/sys_update_name");
            if (Inspector.isOotbAppFile(update_name, state.currentScope)) {
                thisIsChangeToOOTB = true;
                stats.inventory[class_name].ootb_count++;
				
                var link = "<p><a href=\"https://" + Inspector.InstanceName + ".service-now.com/nav_to.do?uri=" +
                    class_name + ".do?sys_id=" + sys_id +
                    "\" target=\"_blank\">" + target_name + " [" + xml_name +
                    "]</a></p>";
                state.boxChangeLinks.push(link);
            }
            if (Spider.appFiles[class_name].has_script && class_name.indexOf("sys_atf") == -1) {
                // Remember to SKIP ATF stuff! We process that later.
                // Don't want to add test LOC into total counts

                // Get script fields in this application file
                var scriptFields = Spider.appFiles[class_name].script_fields;
                if (!scriptFields) {
                    // This app file doesn't have any scripts
                    gs.error("Script fields for " + class_name + " not constructed properly!");
                    return;
                }

                // AST walk handlers needed for script scans
                var scriptHandlers = {
                    FunctionDeclaration: Scanner.statementHandler,
                    FunctionExpression: Scanner.statementHandler,
                    CallExpression: Scanner.callExpressionHandler,
                    AssignmentExpression: Scanner.assignmentExpressionHandler,
                    MemberExpression: Scanner.memberExpressionHandler,
                    VariableDeclarator: Scanner.variableDeclaratorHandler,
                    ExpressionStatement: Scanner.statementHandler,
                    BlockStatement: Scanner.statementHandler,
                    IfStatement: Scanner.statementHandler,
                    LabeledStatement: Scanner.statementHandler,
                    BreakStatement: Scanner.statementHandler,
                    ContinueStatement: Scanner.statementHandler,
                    WithStatement: Scanner.statementHandler,
                    SwitchStatement: Scanner.statementHandler,
                    ReturnStatement: Scanner.statementHandler,
                    ThrowStatement: Scanner.statementHandler,
                    TryStatement: Scanner.tryStatementHandler,
                    WhileStatement: Scanner.statementHandler,
                    DoWhileStatement: Scanner.statementHandler,
                    ForStatement: Scanner.statementHandler,
                    ForOfStatement: Scanner.statementHandler,
                    LetStatement: Scanner.statementHandler,
                    DebuggerStatement: Scanner.statementHandler
                };

                // Script Includes and global business rules have library methods that can be called from
                // other scripts, and tested via ATF. These handlers will keep track of those library methods
                // Note that the business rule "global" is not its scope, but rather it's "table" assignment.
                // Global means it has no specific table. It is always available for execution, i.e. a
                // library method.
                if (class_name == "sys_script_include" || class_name == "sys_script_global") {
                    scriptHandlers.FunctionDeclaration = Scanner.functionDeclarationHandler;
                    scriptHandlers.FunctionExpression = Scanner.functionExpressionHandler;
                }

                // Since we are here in this block, this record has one or more fields of script type. 
                // Want to make sure there actually is script in at least one field, other than comments.
                // That is what we are tracking. The number of application files with 
                // executable script 
                state.has_script = false;
                state.script_sys_id = sys_id;

                var scriptsRunning = false;
                for (var field in scriptFields) {

                    if (scriptFields[field] != "script" && scriptFields[field] != "script_plain")
                        continue; // only processing these right now

                    // Need to filter out processing of scripts that are not active, expecially
                    // given the fact that many scripts have default script and comments that should
                    // not be counted
                    if ("sys_dictionary" == class_name && "calculation" == field) { // DAK
                        var isCalculated = payloadXML.getNodeText("/record_update/" +
                            real_class_name + "/virtual");
                        if (isCalculated != "true")
                            continue;
                    }
                    else if ("metric_definition" == class_name) {
                        var type = payloadXML.getNodeText("/record_update/" +
                            real_class_name + "/type");

                        if (type != "calculation") {
                            // If not calculation, this is no code field duration
                            continue;
                        }
                    }
                    else if ("sys_ui_policy" == class_name) {

                        scriptsRunning = payloadXML.getNodeText("/record_update/" +
                            real_class_name + "/run_scripts");
                        if (scriptsRunning != "true") {
                            // Normally no code in UI Policy
                            continue;
                        }
                    }
                    else if ("sys_transform_entry" == class_name) {

                        scriptsRunning = payloadXML.getNodeText("/record_update/" +
                            real_class_name + "/use_source_script");
                        if (scriptsRunning != "true") {
                            continue;
                        }
                    }
                    else if ("sys_transform_map" == class_name) {

                        scriptsRunning = payloadXML.getNodeText("/record_update/" +
                            real_class_name + "/run_script");
                        if (scriptsRunning != "true") {
                            continue;
                        }
                    }

                    var script = payloadXML.getNodeText("/record_update/" + real_class_name + "/" + field);
                    //var nameField = Spider.appFiles[class_name].name_field;
                    //var name = payloadXML.getNodeText("/record_update/" + real_class_name + "/" + nameField);
                    var record_name = class_name + "::" + sys_id; // Sys ID is better for debug

                    Inspector.scanScript(state, stats, script, record_name, scriptHandlers);

                }
                if (state.has_script == true) {
                    stats.inventory[class_name].scripted_count++;

                    if (state.inspectableLists.active) {


                        //
                        // Find OOTB scripts that have been modified!
                        //

                        if (!state.script_sys_id) {
                            gs.error("Script scanning did not initialized script_sys_id!");
                        }

                        //var update_name = payloadXML.getNodeText("/record_update/" + real_class_name + "/sys_update_name");
                        //var package_node = payloadXML.getNode("/record_update/" + real_class_name + "/sys_package");

                        //var scope_name = state.currentScope;
                        /*
                        Not sure what I was doing here
                        if (scope_name == "global") {
                            var a = package_node.getAttribute("display_value");
                            if (!a) {
                                gs.error("The semantics of the " + real_class_name + "/sys_package attributes have changed!");
                                gs.error("Expected a display_value attribute for a global " + real_class_name + "/sys_package");
                            }
                            scope_name = "Applied Update Set: " + package_node.getAttribute("display_value");
                        }
                        else {
                            scope_name = package_node.getAttribute("source");
                            if (!scope_name) {
                                gs.error("The semantics of the " + real_class_name + "/sys_package attributes have changed!");
                                gs.error("Expected a non-global source attribute for " + real_class_name + "/sys_package");
                            }
                        }
                        */
                        if (thisIsChangeToOOTB) {
                            // This is an update to an OOTB file (since it is not custom)
                            state.inspectableLists.ootbScriptUpdates.push(state.script_sys_id);
                        }
                    }
                }
            }
        }
    }
    catch (e) {

        // Find sys_id for error report
        var id = payload.match(/<sys_id>(.+?)<\/sys_id>/);
        gs.error("Inspector.examinePayload exception, sys_id: " + id[1] + ". Msg: " + e);
    }
};

// Take inventory of a Workflow Activity (wf_activty)
// 
// Caller must ensure that 
//      - The GlideRecord is a wf_activity 
//      - The GlideRecord is active and under inspection, i.e.
//          - Inspector.isRecordUnderInspection(gr, ...) returns true 
//          - Inspector.isActive(gr) is true
// 
// This method will update various metrics based on the record class (table). 
// It will not scan any script (since none exist on the wf_activity record itself.
// We will scan sys_variable_values for the associated scripts, if any.)
Inspector.examineWorkflowActivity = function (stats, state, name, scope) {

    var class_name = "wf_activity";

    try {

        // Initialize the inventory log if necessary
        Inspector.initializeInventoryLog(stats, state, class_name);

        // A parameter into the AST walk basically, since we count code in there
        state.stats.inventoryIndex = class_name;

        stats.inventory[class_name].count++;

        if (!scope || scope == "global") {
            stats.inventory.wf_activity.global_count++;
            state.currentScope = "global";
        }
        else {
            state.currentScope = scope;
        }
    }
    catch (e) {
        gs.error("Inspector.examineWorkflowActivity exception in " + class_name + "::" + name + ". Msg: " + e);
    }
};


// Take inventory of this Variable (sys_variable_value). Caller strips information out of
// the GlideRecord before passing it into this function (enables direct processing of update set
// payloads)
// 
// Caller must ensure that  
//      - The information is from a sys_variable_value record 
//      - The Variable is active and under inspection, i.e.
//          - Inspector.isVariableUnderInspection(gr, ...) returns true, 
//          - Inspector.isActive(gr) is true, or in an active workflow update xml payload 
// 
// This method will scan scripts for script metrics, if any exist.
Inspector.examineVariable = function (stats, state, script_string,
    document_key, var_dictionary_id, var_id) {
    // Parms:
    //      document_key is the sys_id of the record this sys_variable_value is attached to.
    //      var_dictionary_id is the sys_id of the associated var_dicationary record. 
    //      var_id is the sys_id of the sys_variable_value being examined.
    // 
    // 


    // AST walk handlers needed for script scans
    var scriptHandlers = {
        FunctionDeclaration: Scanner.statementHandler,
        FunctionExpression: Scanner.statementHandler,
        CallExpression: Scanner.callExpressionHandler,
        AssignmentExpression: Scanner.assignmentExpressionHandler,
        MemberExpression: Scanner.memberExpressionHandler,
        VariableDeclarator: Scanner.variableDeclaratorHandler,
        ExpressionStatement: Scanner.statementHandler,
        BlockStatement: Scanner.statementHandler,
        IfStatement: Scanner.statementHandler,
        LabeledStatement: Scanner.statementHandler,
        BreakStatement: Scanner.statementHandler,
        ContinueStatement: Scanner.statementHandler,
        WithStatement: Scanner.statementHandler,
        SwitchStatement: Scanner.statementHandler,
        ReturnStatement: Scanner.statementHandler,
        ThrowStatement: Scanner.statementHandler,
        TryStatement: Scanner.tryStatementHandler,
        WhileStatement: Scanner.statementHandler,
        DoWhileStatement: Scanner.statementHandler,
        ForStatement: Scanner.statementHandler,
        ForOfStatement: Scanner.statementHandler,
        LetStatement: Scanner.statementHandler,
        DebuggerStatement: Scanner.statementHandler
    };


    try {

        var class_name = "nada";
        switch (Spider.scriptVariables[var_dictionary_id].label) {
            case "ActivityVariables":
                class_name = "wf_activity";
                break;
            default:
                gs.warn("examineVariable: _isVariableUnderInspection should have filtered out sys_variable_value:" + var_id);
                return;
                break;
        }

        // Initialize the inventory log 
        // Counts for the model records will be taken elsewhere. Only script counts will be taken now.
        // Note that the scripted_count field will be calculated at just before output 
        // from the this.modelsWithScript counts
        Inspector.initializeInventoryLog(stats, state, class_name);

        // A parameter into the AST walk basically, since we count code in there
        state.stats.inventoryIndex = class_name;

        // Want to make sure there actually is script in the field, other than comments
        state.has_script = false;

        // The true scope only matters for tracking libary methods, and looking for
        // calls from ATF test steps to those methods. Therefore, we will just default to global 
        state.currentScope = "global";

        var record_name = "sys_variable_value" + "::" + var_id;

        Inspector.scanScript(state, stats, script_string, record_name, scriptHandlers);

        if (state.has_script == true) {
            stats.modelsWithScript[class_name][document_key] = true;
        }
    }
    catch (e) {
        gs.error("Inspector.examineVariable exception sys_variable_value::" + var_id + ". Msg: " + e);
    }

};

Inspector.isRecordUnderInspection = function (gr, class_name, name_field, isPackageScan) {
    // Return true to continue inspection of record, false to abort
    // This is deprecated. We will inspect everything they have packaged, to varying degrees of course.


    //
    // Validate record class is expected 
    //

    // Ensure we are expecting this type of record
    if (!Spider.appFiles[class_name] && class_name != "wf_activity" && class_name != "sys_variable_value") {
        if (isPackageScan)
            gs.warn("_inspectRecord: unhandled record class was packaged: " + class_name + ":" + gr.sys_id);
        if (isPackageScan)
            gs.error("_inspectRecord: unhandled record class was processed: " + class_name + ":" + gr.sys_id);
        return false; // This isn't an application file or something an application file requires
    }

    return true;

};

Inspector.isVariableUnderInspection = function (var_dictionary_id) {
    // Return true to continue inspection of variable, false to abort
    // gr must be of sys_variable_value class

    // 
    // Filter out variables that aren't being inspected
    //

    try {
        if (!Spider.scriptVariables[var_dictionary_id]) {
            return false; // This isn't a scripted variable
        }

        if (Spider.scriptVariables[var_dictionary_id].scriptType != "script" &&
            Spider.scriptVariables[var_dictionary_id].scriptType != "script_plain") {
            // Not processing email scripts yet
            return false;
        }

        // Only processing ActivityVariables at the moment
        // Need to figure out how the flow designer/integration hub actually is put
        // together
        // Variable processing logic in _inspectRecord should deal with these types
        if (Spider.scriptVariables[var_dictionary_id].label != "ActivityVariables") {
            return false;
        }
    }
    catch (e) {
        gs.error("Inspector.isVariableUnderInspection: Unknown var_dictionary " + var_dictionary_id + ". Msg: " + e);
        return false;
    }
    return true;
};

Inspector.isActive = function (gr, class_name) {
    // Only call this if you know it knows how to test for active on your record type! 
    // If we don't know how to test, we will say its NOT active


    try {

        if (class_name == "wf_activity") {

            if (!gr.workflow_version) {
                return false;
            }
            if (!gr.workflow_version.published) {
                return false;
            }
        }
        else if (class_name == "sys_variable_value") {

            // Need to see if the model (a record) the variable belongs to is active
            var table_name = gr.document.toString();
            var model = new GlideRecord(table_name);
            switch (table_name) {
                case "wf_activity":
                    if (!model.get(gr.document_key)) {
                        return false;
                    }
                    if (!model.workflow_version) {
                        return false;
                    }
                    if (!model.workflow_version.published) {
                        return false;
                    }
                    break;

                case "sys_hub_action_type_definition":
                    if (!model.get(values.document_key)) {
                        return false;
                    }
                    if (!model.active) {
                        return false;
                    }
                    break;


                default:
                    // If we don't know how to handle it, return false;
                    return false;
                    break;

            }
        }
        else if (class_name == "sys_atf_step") {
            // ensure step and parent test are both active
            if (gr.active && gr.test.active) {
                return true;
            }
            else {
                return false;
            }
        }
        else if (gr.isValidField("active")) {
            return gr.getValue("active");
        }
    }
    catch (e) {
        gs.error("Inspector.isActive : " + e);
        return false;
    }

    return true; // If we can't find the active flag, assume it can't be shut off.
};

Inspector.scanScript = function (state, stats, script_string, record_name, ast_walk_handlers) {
    // return true if script actually existed, false if not.

    try {

        if (!script_string) {
            // Nothing to do. The value was null.
            return false;
        }

        stats.CodeCharCount += script_string.length;
        state.stats.inventory[state.stats.inventoryIndex].codeChars += script_string.length;
        if (script_string.length <= 0) {
            // Common now gs.debug("No script in " + gr[name_field]);
            return false;
        }

        var comments = script_string.match(/\/\*[\s\S]*?\*\/|\/\/.*/g);
        if (comments) {

            if (state.inspectableLists.active) {
                state.inspectableLists.commentedScripts.push(state.script_sys_id);
            }

            for (var k = 0; k < comments.length; k++) {
                stats.CommentCharCount += comments[k].length;
                state.stats.inventory[state.stats.inventoryIndex].commentChars += comments[k].length;
            }
        }
        else {
            stats.NoCommentFileCount++;
        }

        var tree = x_snc_dk_acorn.ASTree.parse(script_string);  // Make the Abstract Syntax Tree

        // For dev purposes
        if (state.dumpTree) {
            gs.info(JSON.stringify(tree).replace(/,/g, '\n'));
        }

        x_snc_dk_acorn.ASTree.walk(tree, ast_walk_handlers, null, state);

        // Be explicit (probably not necessary)
        script_string = 0;
        comments = 0;
        tree = 0;
    }
    catch (e) {
        gs.error("Inspector.scanScript: Processing exception in " + record_name + ". " + e);
        // break;
    }
    return true;
};

Inspector.initializeInventoryLog = function (stats, state, class_name) {

    // Initialize the inventory log if necessary
    if (!stats.inventory[class_name]) {
        stats.inventory[class_name] = {
            count: 0,
            scripted_count: 0,
            global_count: 0,
            ootb_count: 0,
            type: "Config" // NoLowCode, ProCode, Test, Config or Custom
        }; // initialize the record counter

        // state is passed into AST walker, which counts lines of code
        // and script side (number of nodes in the syntax tree)
        // (Camel case properties match result record field labels for auto load.)
        state.stats.inventory[class_name] = {
            LinesOfCode: 0,
            ScriptSize: 0,
            try_catch: 0,
            logging: 0,
            debugging: 0,
            codeChars: 0,
            commentChars: 0,
            type: "Config"
        };

        if (Catalog.isNoLowLogicRecord(class_name)) {
            stats.inventory[class_name].type = "NoLowCode";
            state.stats.inventory[class_name].type = "LowCode"; // These stats are all script related, so drop the "No"
        }
        else if (Catalog.isProLogicRecord(class_name)) {
            stats.inventory[class_name].type = "ProCode";
            state.stats.inventory[class_name].type = "ProCode";
        }
        else if (Catalog.isTestRecord(class_name)) {
            stats.inventory[class_name].type = "Test";
            state.stats.inventory[class_name].type = "Test";
        }
        else if (!Spider.appFiles[class_name]) {
            stats.inventory[class_name].type = "Custom";
            state.stats.inventory[class_name].type = "Custom";
        }
        // else (Detault type) is "Config" 
    }
};

Inspector.logTargets = function (state, class_name, sys_id, api) {

    // Log script library files that contain methods that can be called
    // from other application files, and therefore can be whitebox tested
    // (tested with a scripted ATF test.)
    // Also log ATFTestSteps for next round of processing. 
    switch (class_name) {
        case "sys_script_include":
            // "Script Include":
            if (api)
                state.targets.classes[api] = 1;
            break;
        case "sys_script_global":
            // This is an artificial class! Global business rules came before script includes
            break;
        case "sys_atf_step":
            // "Test Step":
            state.targets.files.ATFTestSteps[sys_id] = 1;
            break;

        default:
            break;
    }
};


Inspector.isOotbAppFile = function (sys_update_name, scope_name) {
    // 1st input parm is the sys_update_name field in a sys_metadata record
    // 2nd input parm, scope_name, which can be one of two things:
    // - for private scope, the sys_metadata.sys_scope.scope field.
    //   In an update record, it is also the "source" attribute in the sys_package field, which 
    //   has two attributes: display_value and source.  
    //   In an sys_metadata record, it should be the sys_upgrade_history.to_version field
    // - for global named scope, the sys_metadata.sys_scope.name field (since scope is "global").
    //   In an update record, it is also the "display_value" attribute in the sys_package field
    //   which should be in the sys_upgrade_history.to_version field as "Applied Update Set: <name>"
    //   for an upgrade update.
    // We want to track what OOTB application files have changed down in this method since
    // we have already gone through the trouble to find the version record that identifies
    // the file as being OOTB. For performance, we will record a link to that version, which in turn
    // has a link to it's Application File

    // This customization identification logic derives from ScriptInclude UpdateVersionAPI
    //
    // Notes
    // When an OOTB app file is untouched, there are no versions. When you touch it,
    // either locally or through an update set commit, it gets two versions, the
    // current update whose "Source Table" is "Update Set", and the source
    // is the update set that records the change,
    // and a previous update whose Source Table is "System Upgrade" (sys_upgrade_history),
    // and the source is a particular upgrade (or initial install)
    // A new custom app file won't have a System Upgrade in its history 


    if (sys_update_name.indexOf("sys_dictionary_z") == 0) {
        // Weird thing going on with dictionary entries for privately scoped fields
        // They have a "z" in the sys_update_name, but the version name
        // drops it.
        sys_update_name = sys_update_name.replace(/^sys_dictionary_z/, "sys_dictionary");
    }

    var versions = new GlideRecord('sys_update_version');
    versions.addQuery('name', sys_update_name);
    versions.query();

    // If a file has 0 versions, then normally it is out of the box. There is one 
    // exception I've seen, where the update is in a private scope, and no versions
    // were created. That said, if we are here, scanning updates!, it means that the update
    // happened. If there are no versions, something is wrong. Probably means
    // there was no "original", i.e. nothing out of the box.
    // So, I'll leave all the logic in here, but in our case, if there are no versions, we
    // will consider it something new (not and OOTB modification) 
    if (versions.getRowCount() === 0) {

        return false;

        // Found an anomally. A sys_index was inserted by a privated scoped update set,
        // and no version record was created. Since the update was in the 
        // accelerator and privatedly scoped, it is a customer update by definition.
        // Check for private scope here
        /*
        if (scope_name == "global") {
            return true;
        }
        else {
            return false;
        }
        */
    }

    // Local Update
    // Anything that is updated locally, or installed via update set, will get a 
    // sys_update_set version record. Question is, was an older sys_upgrade_history record
    // around (OOTB), or was this installed via repo/store, or GIT
    // 
    // Update Set change
    // Again, if OOTB, a sys_upgrade_history record will be left behind
    // If there exists a named version of source sys_upgrade_history or sys_store_app, 
    // then not a customer file, with noted GIT exception.
    //
    // GIT Pulls
    // Look like a sys_upgrade_history, only the name of the upgrade is the scope
    while (versions.next()) {
        var sourceTable = versions.source_table.toString();
        if (sourceTable === 'sys_upgrade_history') {
            // If in an upgrade that is NOT the same as its scope, this is OOTB.
            // When an app is installed from GIT, the source is an upgrade with the same name as the scope
            if (versions.source.to_version != scope_name) {
                return true; // This is an OOTB app file
            }
        }
        //else if (sourceTable === 'sys_store_app') {
        //    return true; // This was installed via GIT, which means its custom
        //}
    }

    return false;
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>dave.knight</sys_created_by>
        <sys_created_on>2018-10-22 21:53:03</sys_created_on>
        <sys_customer_update>false</sys_customer_update>
        <sys_id>1338fef94fd1e340ea338e328110c76f</sys_id>
        <sys_mod_count>55</sys_mod_count>
        <sys_name>Inspector</sys_name>
        <sys_package display_value="Validator" source="x_snc_dk_validator">65ec1ebc4f37df40ea338e328110c714</sys_package>
        <sys_policy>read</sys_policy>
        <sys_replace_on_upgrade>false</sys_replace_on_upgrade>
        <sys_scope display_value="Validator">65ec1ebc4f37df40ea338e328110c714</sys_scope>
        <sys_update_name>sys_script_include_1338fef94fd1e340ea338e328110c76f</sys_update_name>
        <sys_updated_by>dave.knight</sys_updated_by>
        <sys_updated_on>2019-03-24 19:40:16</sys_updated_on>
    </sys_script_include>
</record_update>
