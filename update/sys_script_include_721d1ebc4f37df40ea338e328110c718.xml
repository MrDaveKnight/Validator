<?xml version="1.0" encoding="UTF-8"?>
<record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>public</access>
        <active>true</active>
        <api_name>x_snc_dk_validator.Scan</api_name>
        <client_callable>false</client_callable>
        <description/>
        <name>Scan</name>
        <script><![CDATA[var Scan = Class.create();

// These are the "classes" we are interested in tracking in order to gather call statistics.
// TODO make it configurable.
// Note that all classes (script includes actually) are tracked when processing ATF scripts. 
// We want to track all calls, since most will be executing tests.
trackedClasses = {
	GSLog : 1,
	gs : 1
};


Scan.prototype = {
	initialize: function(format, query, dump_tree) {
		
		this.dumpTree = false;
		this.FileCount = 0;
		
		
		// Stats generated by RegEx scans
		this.CodeCharCount = 0;
		this.CommentCharCount = 0;
		this.NoCommentFileCount = 0;
		
		this.isScanLimitedToTargets = false;
		this.targets = {
			ScriptIncludes: {},
			Macros: {},
			Pages: {},
			Processors: {}
		};
		
		if (format && query) {
			// This will restrict the scan and analysis to just the application files
			// identified by the query
			this._logTargetedAppFiles(format, query);
		}
		if (dump_tree)
			this.dumpTree = true;
		
		
		// Stats generated by AST scan
		// NOTICE! Any of the helpers in this file that collect stats must have that stat initialized
		// in this state object!
		this.state = {
			stats: {
				LinesOfCode: 0,
				DebugCallCount: 0,
				LogCallCount: 0,
				GlobalLogCallCount: 0,
		
				// Statement counts
				BlockStatementCount: 0,
				ExpressionStatementCount: 0,
				IfStatementCount: 0,
				LabeledStatementCount: 0,
				BreakStatementCount: 0,
				ContinueStatementCount: 0,
				WithStatementCount: 0,
				SwitchStatementCount: 0,
				ReturnStatementCount: 0,
				ThrowStatementCount: 0,
				TryStatementCount: 0,
				WhileStatementCount: 0,
				DoWhileStatementCount: 0,
				ForStatementCount: 0,
				ForOfStatementCount: 0,
				LetStatementCount: 0,
				DebuggerStatementCount: 0,
		
				FunctionDeclarationCount: 0,
				VariableDeclaratorCount: 0
			},
			CurrentFile: "",
			targetMethods: {},
			atfCallLog: {}
		};	
	},
	
	logStats: function () {
		
		if (this.CodeCharCount <= 0) {
			gs.info("No code was scanned. Nothing to report.");
			return;
		}
		
		gs.info("FileCount: " + this.FileCount);
		gs.info("CommentPercentage: " + ((this.CommentCharCount / this.CodeCharCount) * 100.0).toFixed(1) + "%");
		if (this.state.stats.LinesOfCode > 0) {
			gs.info("LogPercentage: " + 
						((this.state.stats.LogCallCount / this.state.stats.LinesOfCode) * 100.0).toFixed(1) + "%");
			gs.info("DebugPercentage: " + 
						((this.state.stats.DebugCallCount / this.state.stats.LinesOfCode) * 100.0).toFixed(1) + "%");
			gs.info("ExceptionPercentage: " + 
						((this.state.stats.TryStatementCount / this.state.stats.LinesOfCode) * 100.0).toFixed(1) + "%");
		}
		else {
			gs.info("No executable lines of code scanned. Nothing to report on log, debug and exception handling percentages.");
		}
		gs.info("NoCommentFileCount: " + this.NoCommentFileCount);
		for (var p in this.state.stats) {
			gs.info(p + ": " + this.state.stats[p]);
		}
		
		var targetedMethodCount = 0;
		var testedMethodCount = 0;
		for (var q in this.state.targetMethods) {
			targetedMethodCount++;
			if (this.state.targetMethods[q] > 0)
				testedMethodCount++;
		}
		gs.info("ModifiedMethodCount:" + targetedMethodCount);
		gs.info("TestedMethodCount:" + testedMethodCount);
	},
	
	
	
	scriptIncludes: function () {
		
		// AST walk handlers
		var scriptIncludeHandlers = {
			FunctionDeclaration: functionDeclarationHandler,
			FunctionExpression: functionExpressionHandler,
			CallExpression: callExpressionHandler,
			VariableDeclarator:  variableDeclaratorHandler,
			ExpressionStatement: expressionStatementHandler,
			BlockStatement : statementHandler,
			IfStatement : statementHandler,
			LabeledStatement : statementHandler,
			BreakStatement : statementHandler,
			ContinueStatement : statementHandler,
			WithStatement : statementHandler,
			SwitchStatement : statementHandler,
			ReturnStatement : statementHandler,
			ThrowStatement : statementHandler,
			TryStatement : tryStatementHandler,
			WhileStatement : statementHandler,
			DoWhileStatement : statementHandler,
			ForStatement : statementHandler,
			ForOfStatement : statementHandler,
			LetStatement : statementHandler,
			DebuggerStatement : statementHandler
		};
		
		var gr = new GlideRecord("sys_script_include");
		gr.addActiveQuery();
		gr.query();
		while (gr.next()) {	
			if (this.isScanLimitedToTargets && !this.targets.ScriptIncludes[gr.sys_id.toString()])
				continue; // skip it if not targeted for analysis
			this.state.CurrentFile = gr.name.toString();
			this._executeScanOverScript (gr, "name", "script", scriptIncludeHandlers);
		}
	},
	
	ATFTests: function () {
		
		// AST walk handlers
		var atfScriptHandlers = {
			FunctionDeclaration: functionDeclarationHandler,
			CallExpression: callExpressionHandler,
			VariableDeclarator:  variableDeclaratorHandler,
			ExpressionStatement: expressionStatementHandler,
			BlockStatement : statementHandler,
			IfStatement : statementHandler,
			LabeledStatement : statementHandler,
			BreakStatement : statementHandler,
			ContinueStatement : statementHandler,
			WithStatement : statementHandler,
			SwitchStatement : statementHandler,
			ReturnStatement : statementHandler,
			ThrowStatement : statementHandler,
			TryStatement : tryStatementHandler,
			WhileStatement : statementHandler,
			DoWhileStatement : statementHandler,
			ForStatement : statementHandler,
			ForOfStatement : statementHandler,
			LetStatement : statementHandler,
			DebuggerStatement : statementHandler
		};
		
		// Find all ATF configuration input variables of script type (script and script_plain currently.)
		var atfScriptTypesGR = new GlideRecord("atf_input_variable");
		atfScriptTypesGR.addActiveQuery();
		atfScriptTypesGR.addEncodedQuery("internal_typeLIKEscript");  
		atfScriptTypesGR.query();
		while (atfScriptTypesGR.next()) {
			
			// Find actual test step input variables that are configured as one of these script types, and scan ...
			var atfScriptsGR = new GlideRecord("sys_variable_value");
			atfScriptsGR.addQuery("document", "sys_atf_step");
			atfScriptsGR.addQuery("variable", atfScriptTypesGR.sys_id);
			atfScriptsGR.query();
			while (atfScriptsGR.next()) {
				// The script is in the value field of an input variable. Since there is no name
				// for the input variable, we will track it by GUID
			   this._executeScanOverScript (atfScriptsGR, "document_key", "value", atfScriptHandlers);
			}
		}
	},
	
	_executeScanOverScript: function (gr, name_field, script_field, ast_walk_handlers) {
		try {

			this.FileCount++;

			var code = gr[script_field].toString();
			this.CodeCharCount += code.length;
			if (code.length <= 0) {
				gs.info("No script in " + gr[name_field]);
			}

			var comments = code.match(/\/\*[\s\S]*?\*\/|\/\/.*/g);
			if (comments) {
				for (var k = 0; k < comments.length; k++) {
					this.CommentCharCount += comments[k].length;
				}
			}
			else {
				this.NoCommentFileCount++;
			}

			var tree = x_snc_dk_acorn.ASTree.parse(code);  // Make the Abstract Syntax Tree
			
			// For dev purposes
			if (this.dumpTree) {
				gs.info(JSON.stringify(tree).replace(/,/g, '\n'));
			}
			x_snc_dk_acorn.ASTree.walk(tree, ast_walk_handlers, null, this.state);

			// Be explicit (probably not necessary)
			code = 0;
			comments = 0;
			tree = 0;	
		}
		catch (e) {
			gs.error("MAJOR Processing exception in " + gr[name_field] + ". " + e);
			// break;
		}
	},

	_logTargetedAppFiles: function (format, query) {
		
		this.isScanLimitedToTargets = true;
		
		var packageRecordName = "";
		switch (format) {
			case "remote_update_set":
				packageRecordName = "sys_remote_update_set";
				break;
			case "update_set":
				packageRecordName = "sys_update_set";
				break;
			case "scope":
				packageRecordName = "sys_scope";
				break;
			case "plugin":
				packageRecordName = "v_plugin";
				break;
			default:
				gs.error("Invalid accelerator packaging format. Aborting!");
				throw "exit";
		}
		
		var gr = new GlideRecord(packageRecordName);
		gr.addEncodedQuery(query);
		gr.query();
		while (gr.next()) {
			switch (format) {
			case "remote_update_set":
			case "update_set":
				this._logFromUpdate(gr.sys_id.toString());
				break;
			case "scope":
				this._logFromScope(gr);
				break;
			case "plugin":
				this._logFromPlugin(gr);
				break;
			default:
				gs.error("Invalid accelerator packaging format. Aborting!");
				throw "exit";
			}	
		}
	},
		
	_logFromUpdate: function (update_set_id) {
		var gr = new GlideRecord("sys_update_xml");
		gr.addQuery("update_set", update_set_id);
		gr.addQuery("action", "INSERT_OR_UPDATE");
		//gr.addQuery("type", "Script Include");
		gr.query();
		while (gr.next()) {
			// There should be only one match for this tag.
			// The capture group (the sys_id alone) will be in the 2nd spot in the array
			var id = gr.payload.toString().match(/<sys_id>(.+)<\/sys_id>/);
			switch (gr.type.toString()) {
				case "Script Include":
					this.targets.ScriptIncludes[id[1]] = 1;
					break;
				default:
					break;
			}
		}
	},
	
	
	_logFromPlugin: function (pluginGR) {
	
		var appFileGR = new GlideRecord("sys_metadata");
	
		// Copied from "Plugin Files" Relationship
		// get the package sys_id
		var packageID = "-1";
		var scopeName = !pluginGR.scope.nil() ? pluginGR.scope.toString() : 'global';

		// check if the source is actually a scoped application
		// if so the packageID is the scopeID
		var scope = new GlideRecord('sys_scope');
		if (scopeName !== 'global' && scope.get('scope', scopeName)) {
			packageID = scope.getUniqueValue();
			var files = new GlideRecord('sys_metadata');
			files.addQuery('sys_package', packageID);
			files.addQuery('sys_customer_update', true);
			files.query();
			// exclude customer files if any
			var customerFileIds = new global.UpdateVersionAPI().getCustomerFileIds(files);
			if (customerFileIds.length > 0)
				appFileGR.addQuery('sys_id', 'NOT IN', customerFileIds);
		} else {
			var plugin = new GlideRecord("sys_plugins");
			if (plugin.get("source", pluginGR.id.toString()))
				packageID = plugin.getUniqueValue();
		}

		appFileGR.addQuery("sys_package", packageID);
		appFileGR.query();
		while (appFileGR.next()) {
			switch (appFileGR.sys_class_name.toString()) {
				case "sys_script_include":
					this.targets.ScriptIncludes[appFileGR.sys_id.toString()] = 1;
					break;
				default:
					break;
			}
		}
	},
	
	type: 'Scan'
};


//
// Abstract Syntax Tree walk handers - which are callbacks passed to the AST walker 
// (These can't be in the Scan class, since the this context is lost on the callback)
//

function statementHandler (node, state, ancestors) {
	
	state.stats[node.type + "Count"]++;
	state.stats.LinesOfCode++;
}

function functionDeclarationHandler (node, state, ancestors) {
	
	state.stats[node.type + "Count"]++;
}

function tryStatementHandler (node, state, ancestors) {
	
	state.stats.LinesOfCode++;
	
	try {
		// only count try/catch that does something in the catch
		if (node.handler.body.body)
			state.stats[node.type + "Count"]++;
		
	} catch (e) {
		gs.error(e);
	}
}

function variableDeclaratorHandler (node, state, ancestors) {
	
	// We are tracking defined, in scope variables that reference tracked objects defined in the
	// trackedClasses object above, what we will call "classes of interest".
	// When a variable is declared, it can be initialized directly with one of those classes of interest,
	// or it can be initialized indirectly, to another variable, which in turn references one of those classes of interest.
	// The state.variables.<function_depth>.<class_of_interest> object tracks those declarations. Each
	// property is an array of all the declared variables that refer to that particular class of interest.
	
	try {
		
		state.stats[node.type + "Count"]++;
		state.stats.LinesOfCode++;
		
		//gs.debug("Processing declaration function depth " + state.function_depth + " in " +
		//JSON.stringify(node));
		
		if (node.type == "VariableDeclarator" &&
			node.id.type == "Identifier" &&
		node.init)
		{
			var detectedClass = 0;
			if (node.init.type == "NewExpression" &&
				node.init.callee.type == "Identifier") {
				
				detectedClass = _getTrackedClass(node.init.callee.name, state);
				
			}
			else if (node.init.type == "CallExpression" &&
				node.init.callee.type == "MemberExpression" &&
			node.init.callee.object.type == "NewExpression" &&
			node.init.callee.object.callee.type == "Identifier") {
				
				detectedClass = _getTrackedClass(node.init.callee.object.callee.name, state);
				
			}
			else if (node.init.type == "Identifier") {
				
				detectedClass = _getTrackedClass(node.init.name, state);
				
			}
			
			if (detectedClass) {
				_insertTrackedObject(node.id.name, detectedClass, state, ancestors);
			}
			
		}
	} catch (ex) {
		gs.error("Bad node syntax in VariableDeclaration. " + ex);
		gs.debug("Bad node: " + JSON.stringify(node));
	}
}

function expressionStatementHandler (node, state, ancestors) {
	try {
		
		state.stats.LinesOfCode++;
		state.stats[node.type + "Count"]++;
		
		var detectedClass = 0;
		if (node.expression.type == "AssignmentExpression" &&
			node.expression.operator == "=" &&
		node.expression.right.type == "Identifier" &&
		node.expression.left.type == "Identifier") {
			
			detectedClass = _getTrackedClass(node.expression.right.name, state);
			
		}
		
		if (detectedClass) {
			_insertTrackedObject(node.expression.left.name, detectedClass, state, ancestors);
		}
		
		
	} catch (e) {
		gs.error("Error in expressionStatementHandler. " + e);
	}
}

function atfCallExpressionHandler (node, state, ancestors) {
	
	try {
		if (node.callee.type == "MemberExpression" && node.callee.property.type == "Identifier") {
			
			if (node.callee.object.type == "Identifier") {
				
				
				
				if (_isThisObjectThisThing(node.callee.object.name, "gs", state))
					_callExpressionHandlerHelper("gs", node.callee.object.name,
				node.callee.property.name, state, ancestors);
				else if (_isThisObjectThisThing(node.callee.object.name, "GSLog", state))
					_callExpressionHandlerHelper("GSLog", node.callee.object.name,
				node.callee.property.name, state, ancestors);
				
			}
			else if (node.callee.object.type == "NewExpression" && node.callee.object.callee.type == "Identifier" ) {
				
				
				if (_isThisObjectThisThing(node.callee.object.callee.name, "gs", state))
					_callExpressionHandlerHelper("gs", node.callee.object.callee.name,
				node.callee.property.name, state, ancestors);
				else if (_isThisObjectThisThing(node.callee.object.callee.name, "GSLog", state))
					_callExpressionHandlerHelper("GSLog", node.callee.object.callee.name,
				node.callee.property.name, state, ancestors);
				
			}
		}
	}
	catch (e) {
		gs.error("Error in callExpressionHandler: " + e + ". Node: " + JSON.stringify(node));
	}
}

function callExpressionHandler (node, state, ancestors) {
	
	try {
		if (node.callee.type == "MemberExpression" && node.callee.property.type == "Identifier") {
			
			if (node.callee.object.type == "Identifier") {
				
				if (_isThisObjectThisThing(node.callee.object.name, "gs", state))
					_callExpressionHandlerHelper("gs", node.callee.object.name,
				node.callee.property.name, state, ancestors);
				else if (_isThisObjectThisThing(node.callee.object.name, "GSLog", state))
					_callExpressionHandlerHelper("GSLog", node.callee.object.name,
				node.callee.property.name, state, ancestors);
				
			}
			else if (node.callee.object.type == "NewExpression" && node.callee.object.callee.type == "Identifier" ) {
				
				
				if (_isThisObjectThisThing(node.callee.object.callee.name, "gs", state))
					_callExpressionHandlerHelper("gs", node.callee.object.callee.name,
				node.callee.property.name, state, ancestors);
				else if (_isThisObjectThisThing(node.callee.object.callee.name, "GSLog", state))
					_callExpressionHandlerHelper("GSLog", node.callee.object.callee.name,
				node.callee.property.name, state, ancestors);
				
			}
		}
	}
	catch (e) {
		gs.error("Error in callExpressionHandler: " + e + ". Node: " + JSON.stringify(node));
	}
}

function functionExpressionHandler (node, state, ancestors) {
	
	
	try {
		var methodName = "";
		
		var parent = ancestors[ancestors.length - 2];

		if (parent.type == "AssignmentExpression" && parent.operator == "=" &&
		   parent.left.type == "MemberExpression" && parent.left.property.type == "Identifier") {
			// Prototype methods are initialized with an AssignmentExpression of Left = Right, 
			// where the Right side is a FunctionExpression
			methodName = state.CurrentFile + "." + parent.left.property.name;
			state.targetMethods[methodName] = 0;
		}
		/*
		else if (parent.type == "Property" && parent.key.type == "Identifier" &&
			    grandparent && grandparent.type == "ObjectExpression" &&
				greatgrandparent && greatgrandparent.type == "AssignmentExpression" && 
				greatgrandparent.operator == "=" && greatgrandparent.left.type == "MemberExpression" &&
				greatgrandparent.left.object.type == "Identifier" && 
				 greatgrandparent.left.object.name == state.CurrentFile) {
			methodName = state.CurrentFile + "." + parent.key.name;
			state.targetMethods[methodName] = 0;
		}
		*/
		else if (parent && parent.key && parent.key.name) {
			methodName = state.CurrentFile + "." + parent.key.name;
			state.targetMethods[methodName] = 0;
		}
	}
	catch (e) {
		gs.error("Error in functionExpressionHandler: " + e + ". Node: " + JSON.stringify(node));
	}
}

//
// Utility methods
//

function _callExpressionHandlerHelper (class_name, caller_name, method_name, state, ancestors) {
	
	if (class_name == "gs") {
		if (method_name == "info" ||
			method_name == "warn" ||
		method_name == "error") {
			
			state.stats.LogCallCount++;
			gs.debug("Found GlideSystem logging. " + caller_name + "." + method_name);
			
		}
		else if (method_name == "debug") {
			
			state.stats.DebugCallCount++;
			gs.debug("Found GlideSystem debug. " + caller_name + "." + method_name);
			
		}
		else if (method_name == "log") {
			
			state.stats.GlobalLogCallCount++;
			gs.debug("Found GlideSystem global log. " + caller_name + "." + method_name);
			
		}
	}
	else if (class_name == "GSLog") {
		if (method_name == "info" ||
			method_name == "warn" ||
		method_name == "error" ||
		method_name == "logInfo" ||
		method_name == "logNotice" ||
		method_name == "logWarning" ||
		method_name == "logErr" ||
		method_name == "logCrit" ||
		method_name == "logAlert" ||
		method_name == "logEmerg") {
			
			state.stats.LogCallCount++;
			gs.debug("Found GSLog logging. " + caller_name + "." + method_name);
			
		}
		else if (method_name == "logDebug") {
			
			state.stats.DebugCallCount++;
			gs.debug("Found GSLog debug. " + caller_name + "." + method_name);
			
		}
	}
	
}

function _getTrackedClass (object_name, state) {
	// object_name could be a class name or a variable name.
	// If it is a class name, and is in the trackedClasses object,
	// it is also the tracked class name.
	// If it is a variable, we must look to see if that variable is referencing a tracked class.
	// If so, return that tracked class.
	// Returns null if object is not an instantiation of a tracked class, which also could mean it is not 
	// yet initialized to anything.
	if (trackedClasses[object_name])
		return object_name;
	
	for (var p in state.variables[state.function_depth]) {
		if (state.variables[state.function_depth][p].indexOf(object_name) != -1) {
			return p;
		}
	}
	return null;
}

function _getClassOfMethod (object_name, state) {
	// This should only be called for an object that has just had one of its function properties executed.
	// Therefore, object_name could be a class name or a variable name
	// If it is a variable, it must have already been initialized to a class since we are calling a method on it,
	// so look for it's class in the function tracker
	// If it is a class, 
	
	
	for (var p in state.variables[state.function_depth]) {
		if (state.variables[state.function_depth][p].indexOf(object_name) != -1) {
			return p;
		}
	}
	return null;
}

function _isThisObjectThisThing (object_name, class_name, state) {
	
	if (object_name == class_name)
		return true;
	if (state.variables[state.function_depth] && state.variables[state.function_depth][class_name])
		return (state.variables[state.function_depth][class_name].indexOf(object_name) != -1);
	
	return false;
}

function _insertTrackedObject (object_name, class_name, state, ancestors) {
	
	if (state.variables[state.function_depth][class_name])
		state.variables[state.function_depth][class_name].push(object_name);
	else
		state.variables[state.function_depth][class_name] = [object_name];
	
	gs.debug("Found " + class_name + " instantiation in " +  _findContainingFunctionName(ancestors) +
	"." + object_name + ", function depth " + state.function_depth);
}

function _findContainingFunctionName (ancestors) {
	// Walk back up the ansestor nodes looking for a FunctionDeclaration or a FunctionExpression,
	// whichever comes first.
	for (var x = ancestors.length - 1; x >= 0; x--) {
		if (!ancestors[x].type) continue;
			if (ancestors[x].type == "FunctionDeclaration") {
			return ancestors[x].id.name;
		}
		else if (ancestors[x].type == "FunctionExpression") {
			// Go back one more to the parent property, a key:value pair.
			// The FunctionExpression is the value. The name is an identier in the key
			if (0 == x) throw "Could not find ancenstor for function identification";
				--x;
			if (ancestors[x].type != "Property") throw "Unknown ancestor type found during function identification";
				return ancestors[x].key.name;
		}
	}
}


]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>dave.knight</sys_created_by>
        <sys_created_on>2018-08-06 03:43:03</sys_created_on>
        <sys_customer_update>true</sys_customer_update>
        <sys_id>721d1ebc4f37df40ea338e328110c718</sys_id>
        <sys_mod_count>80</sys_mod_count>
        <sys_name>Scan</sys_name>
        <sys_package display_value="Validator" source="x_snc_dk_validator">65ec1ebc4f37df40ea338e328110c714</sys_package>
        <sys_policy>read</sys_policy>
        <sys_replace_on_upgrade>false</sys_replace_on_upgrade>
        <sys_scope display_value="Validator">65ec1ebc4f37df40ea338e328110c714</sys_scope>
        <sys_update_name>sys_script_include_721d1ebc4f37df40ea338e328110c718</sys_update_name>
        <sys_updated_by>dave.knight</sys_updated_by>
        <sys_updated_on>2018-08-10 11:36:45</sys_updated_on>
    </sys_script_include>
</record_update>
