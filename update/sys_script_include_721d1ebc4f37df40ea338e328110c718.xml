<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>public</access>
        <active>true</active>
        <api_name>x_snc_dk_validator.Main</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <name>Main</name>
        <script><![CDATA[var Main = Class.create();

/*

Standard Usage - Use "Run" modules in Validator application

Scripted Usage
__________________

To scan an accelerator packaged in Update Sets

    var results = new GlideRecord("x_snc_dk_valid_res_metrics");
    var validator = new x_snc_dk_validator.Main(results, "Scan description");
    validator.processPackagedAppFiles("update_set", "state=complete");
    validator.saveResults();

To scan all Application Files (which includes Workflow Activities and Variables) on an instance

    var results = new GlideRecord("x_snc_dk_valid_res_metrics");
    var validator = new x_snc_dk_validator.Main(results, "Scan description");
    validator.processAllApplicationFiles();
    validator.saveResults();

Terminology
--------------
There are two types of "Class" in this program
    #1 The Class created by a Script Include
    #2 The Class or type of a table (sys_class_name)

This Main script uses definition #2 exclusively. The Scanner library uses definition #1. 

Design Notes
--------------

* Processing Flow

There are two phases
1. look at ... (ignore test scripts)
2. Check for test coverage

For Update Set packages: iterate over each update set, iterating over each sys_update_xml record,
counting the total number of sys_update_xml records for the progress bar. Then iterate
over all the update sets calling this._processUpdateSet().

_processUpdateSet will iterate over all INSERT_OR_UPDATE sys_update_xml records in the update set,
calculating its checksum, and then  ...
  -- If it is a "Workflow", parse a variety of information out of the payload,
     calling examineWorkflowActivity() for each activity, along with 
     Inspector.examineVariable() on all of the associated activity variables
  -- If not a Workflow, call Inspector.examinePayload(), passing in the payload.
     examinePayload will call Inspector.logTargets() which tracks the script library
     application files, and all of the ATF steps, which act as filters and targets 
     for the test coverage processing of phase II




* Logging Statistics

During "targeted" script scanning, detect all variable declarations and assignments of "tracked" classes, 
and their function nesting depth so we can deal with function scoping and variable overrides, 
and record the "Class" of object those variables represent. Currently, a tracked class is one that relates
to logging. A targeted script will be in the package(s) identified during Main initialization. 

The Class name saved will be fully qualified, i.e. <scope>.<Class>. Save this name in state.variables.<function_depth>.<variable_name> = <scope>.<class>. This information will be used to identify method calls to tracked objects
such as "gs" or "GSLog". The global scope is "global". 

* White Box Test Statistics

During targeted script scanning, detect all function declarations, and record their fully qualified method name,
i.e. <scope>.<Class>.<function_property>. Save this information in state.targets.methods.<method>

The method names in state.targets.methods will indicate what is eligable for a scripted ATF test.
The value of each state.targets.methods.<method_name> will be the number of ATF calls to that method.

During testCoverage scanning, detect all variable declarations and assignments, at their function nesting
depth, and record the Class of object those variables represent. This will be a fully qualified class, 
i.e. <scope>.<Class_name>. Save this information in 
state.variables.<function_depth>.<variable_name> = <scope>.<Class>. This information will be used to 
identify calls to targeted functions. The call is identified as <scope>.<Class>.<function>. If
the scope is not used as a class prefix in the ATF source code, add the implied scope, 
which is the scope of the ATF test.

*/

// These are the "classes" we are interested in tracking in order to gather call statistics
// other than ATF. for now, it is classes associated with logging. TODO make it configurable.
// Side Note - all classes (script includes actually) are targeted when processing ATF scripts. 
// We want to track all calls, to any Script Include method, since most will be executing tests.
// This data structure is for everything except ATF.
trackedClasses = {
    gs: 1
};
trackedClasses["global.GSLog"] = 1; // The dot causes issues with static initialization



Main.prototype = {

    // Types of ATF test
    CODELESS: "codeless",
    SCRIPTED: "scripted",

    initialize: function (results, desc) {
        // results must be null or a x_snc_dk_valid_res_metrics GlideRecord


        this.activeTargetedAtfSteps = {};

        // For progress calculations
        this.itemsToProcess = 0;
        this.itemsProcessed = 0;
        this.progressUpdateMilestone = 0;
        this.progressUpdatePeriod = 3000; // 3 seconds


        // Stats will be passed around to a variety of classes (modules) for processing.
        // Capitalized variables will be output eventually.
        this.stats = {

            startedAt: gs.hoursAgo(0),
            checksum: 0, // Accelerator package checksum
            description: desc,
            inspectionSampleSize: 5, // Number of artifacts in each sample set

            // Stats generated by RegEx scans over script
            CodeCharCount: 0,
            CommentCharCount: 0,
            NoCommentFileCount: 0,

            // Atf 
            ActiveCodelessSteps: 0,
            ActiveScriptedSteps: 0,
            LinesOfTestCode: 0,

            // Models (dynamically defined tables like Catalog Items for example) with 
            // scripted variables (the dynamic fields for the model) 
            // that actually have script in them. Just because a scripted field
            // is declared, it doesn't mean it actually has script in it. 
            // We want to track the number of models that actually have some
            // script associated with them.
            modelsWithScript: {
                // This needs to be in sync with switch statement in Inspector.examineVariable!  
                wf_activity: {}, // Only this guy is being used at the moment
                sys_hub_action_type_definition: {} // This is not being used at the moment
            },

            // Counts of active records in all application file classes
            inventory: {}
        };


        // State will be uses during script scanning. The AST walker scripts expect
        // a "state" parameter. It will be passed down into the Scanner class.
        // It collects stats related to script scanning, and also holds scan state information.
        this.state = {

            status: "Initialization",
            progress: 0.0,
            resultsGR: results, // Null, or a x_snc_dk_valid_res_metrics GlideRecord

            // Stats generated by AST scan
            // NOTICE! Any of the helpers in this file that collect stats must have that stat initialized
            // in this state object!
            stats: {
                ScriptSize: 0, // The number of nodes in the script's syntax tree. Counted by Acorn::Walker script include
                LinesOfCode: 0,  // Javascript statements, variable declarations, assignment expressions and function calls
                DebugCalls: 0,
                LogCalls: 0,
                GlobalLogCalls: 0,

                // Statement counts
                // Format: <AST Parser Node Type>Count
                BlockStatements: 0,
                ExpressionStatements: 0,
                IfStatements: 0,
                LabeledStatements: 0,
                BreakStatements: 0,
                ContinueStatements: 0,
                WithStatements: 0,
                SwitchStatements: 0,
                ReturnStatements: 0,
                ThrowStatements: 0,
                TryStatements: 0,
                WhileStatements: 0,
                DoWhileStatements: 0,
                ForStatements: 0,
                ForOfStatements: 0,
                LetStatements: 0,
                DebuggerStatements: 0,

                FounctionDeclarations: 0,
                FunctionExpressions: 0,
                VariableDeclarators: 0,

                inventory: {},      // Script metrics for each table class
                inventoryIndex: "",  // Set this before each script scan

                // For random inspection
                // These will all be sys_metadata sys_ids in order to create links
                inspectableLists: {
                    active: false, 
                    ootbScriptUpdates: [], // this requies hitting sys_update_version records unfortunately
                    commentedScripts: [],
                    loggingScripts: [],
                    whiteBoxTests: [],
                    blackBoxTests: []
                }
            },
            targets: {
                files: {
                    ATFTestSteps: {},
                },
                classes: {},
                methods: {}
            },
            processingPackages: false, // As opposed to scanning everything on the box
            query: "", // Package filter
            format: "", // Type of package
            dumpTree: false,
            has_script: false,  // Reset this before each script scan
            script_sys_id: "",  // Reset this before each script scan. For tracking inspectable items
            variables: {},
            block_scope: {},
            function_depth: 0,
            block_depth: 0,
            currentScope: ""
        };

        this.state.variables[0] = {}; // CHG1
        this.state.block_scope[0] = {};

        if (this.state.resultsGR) {
            this.state.stats.inspectableLists.active = results.getValue("inspect");
            this.state.resultsGR.status = this.state.status;
            this.state.resultsGR.started = this.stats.startedAt;
            this.state.resultsGR.progress = 0.0;
            //this.state.resultsGR.setWorkflow(false);
            this.state.resultsGR.update();
        }

        // TODO Do property lookup for this
        //    this.state.dumpTree = true;

    },

    saveResults: function () {

        new Output(this.stats, this.state).run();

    },

    processAllApplicationFiles: function () {

        // Phase 1 counts (matches interation below)
        for (var table_class_name in Spider.appFiles) {
            if (!gs.tableExists(table_class_name)) {
                continue;
            }
            if (Spider.appFiles[table_class_name].is_restricted == true) {
                continue; // TODO Can we do something about this?
            }
            var c = new GlideRecord(table_class_name);
            c.addActiveQuery();  // Only interested in active records
            c.query();
            while (c.next()) {
                if (c.sys_class_name != table_class_name)
                    continue;
                this.itemsToProcess++;
            }
        }
        // Phase 2 counts
        var wfc = new GlideRecord("wf_activity");
        wfc.query();
        while (wfc.next()) {
            if (!Inspector.isActive(wfc, "wf_activity")) {
                continue;
            }
            this.itemsToProcess++;
        }
        // Phase 3 counts
        var vc = new GlideRecord("sys_variable_value");
        vc.query();
        while (vc.next()) {

            var var_dictionary_id = vc.variable.toString();
            if (!Inspector.isVariableUnderInspection(var_dictionary_id)) {
                continue;
            }
            if (!Inspector.isActive(vc, "sys_variable_value")) {
                continue;
            }
            this.itemsToProcess++;
        }



        // AST walk handlers
        var scriptHandlers = {
            FunctionDeclaration: Scanner.statementHandler,
            FunctionExpression: Scanner.statementHandler,
            CallExpression: Scanner.callExpressionHandler,
            AssignmentExpression: Scanner.assignmentExpressionHandler,
            MemberExpression: Scanner.memberExpressionHandler,
            VariableDeclarator: Scanner.variableDeclaratorHandler,
            ExpressionStatement: Scanner.statementHandler,
            BlockStatement: Scanner.statementHandler,
            IfStatement: Scanner.statementHandler,
            LabeledStatement: Scanner.statementHandler,
            BreakStatement: Scanner.statementHandler,
            ContinueStatement: Scanner.statementHandler,
            WithStatement: Scanner.statementHandler,
            SwitchStatement: Scanner.statementHandler,
            ReturnStatement: Scanner.statementHandler,
            ThrowStatement: Scanner.statementHandler,
            TryStatement: Scanner.tryStatementHandler,
            WhileStatement: Scanner.statementHandler,
            DoWhileStatement: Scanner.statementHandler,
            ForStatement: Scanner.statementHandler,
            ForOfStatement: Scanner.statementHandler,
            LetStatement: Scanner.statementHandler,
            DebuggerStatement: Scanner.statementHandler
        };

        try {
            var limiter = 0;
            var theLimit = 10000;

            // 
            // Transition to Running state
            //

            if (this.state.resultsGR) {
                this.state.status = "Running";
                this.state.resultsGR.status = this.state.status;
                this.state.resultsGR.update();
            }


            //
            // Phase 1
            //
            // Process all Application File descendant records
            //

            for (var table_class_name in Spider.appFiles) {

                if (!gs.tableExists(table_class_name)) {
                    gs.error("processAllApplicationFiles: Spider identified a non-existent table, " + table_class_name + ". Ignoring.");
                    continue;
                }

                if (Spider.appFiles[table_class_name].is_restricted == true) {
                    continue; // TODO Can we do something about this?
                }

                if (++limiter > theLimit)
                    break;

                var af = new GlideRecord(table_class_name);
                af.addActiveQuery();  // Only interested in active records
                af.query();
                var limit = 0;  // for test
                while (af.next()) {

                    // Only process records that are in this class, as opposed to descendents of this class.
                    // If the application file is a decendent of the class we are processing, 
                    // we will get around to looking at it when we scan it's class.
                    if (af.sys_class_name != table_class_name)
                        continue;

                    Inspector.examineRecord(this.stats, this.state, af, table_class_name, Spider.appFiles[table_class_name].name_field, null, false);

                    this._checkProgress();
                }
            }

            //
            // Phase 2
            //
            // Workflow Activities
            //
            // This is a special case. Workflow activity definitions are App Files, but 
            // Workflow Activities themselves are not. Packaging is handled with the workflow itself, 
            // which is the app file.
            //
            // Only collecting record counts. 
            // Iterate over all workflow activities that are associated with a published workflow. 

            limiter = 0;
            var wfa = new GlideRecord("wf_activity");
            wfa.query();
            while (wfa.next()) {

                if (++limiter > theLimit)
                    break;

                if (!Inspector.isActive(wfa, "wf_activity")) {
                    continue;
                }
                Inspector.examineWorkflowActivity(this.stats, this.state,
                    wfa.name.toString(), wfa.workflow_version.workflow.sys_scope.toString());

                this._checkProgress();
            }

            //
            // Phase 3
            //
            // Process Variables
            //
            // Only collecting script metrics here!
            // Iterate over all variable "values". The ones that are actually a script
            // are identified by the Spider.scriptVariables object and will be deemed
            // as "Under Inspection".
            var v = new GlideRecord("sys_variable_value");
            v.query();

            limiter = 0;
            theLimit = 1000;

            while (v.next()) {

                if (++limiter > theLimit)
                    break;

                var var_dictionary_id = v.variable.toString();
                if (!Inspector.isVariableUnderInspection(var_dictionary_id)) {
                    continue;
                }
                if (!Inspector.isActive(v, "sys_variable_value")) {
                    continue;
                }

                var script_value = v.value.toString(); // To be under inspection, must be a script
                var document_key = v.document_key.toString();
                var var_id = v.sys_id.toString();

                Inspector.examineVariable(this.stats, this.state, script_value,
                    document_key, var_dictionary_id, var_id);

                this._checkProgress();
            }
        }
        catch (e) {
            gs.error("processAllApplicationFiles: Unhandled exception during scans. Aborting. Msg: " + e);
            this.state.status = "Error";
            this.state.resultsGR.update();

            throw "exit";
        }

        this.state.status = "Complete";
    },


    _scanTestCoverage: function () {


        if (!this.state.processingPackages) {
            gs.error("Usage error: You must define a package for test coverage analysis.");
            return;
        }

        // First, collect the ids of all active test scripts that were identified by the targeted
        // updates/pluggins. Some may not have been active. This is because a step and it's parent
        // test must be active, and during update set payload processing of a test step, we don't 
        // bother to go find the update set payload of it's test. So ... we may have some deactived
        // tests. We will find that now by getting the gliderecord which will make the test for 
        // parent test status easy.
        //
        // For the active steps, default their type to codeless, even though some may be scripted. 
        // We will find the scripted ones shortly.
        var atfStepsGR = new GlideRecord("sys_atf_step");
        atfStepsGR.addQuery("active", true);
        atfStepsGR.addQuery("test.active", true);
        // Since I'm not sure how big the sys_id string can be before blowing up a GlideRecord
        // encodedQuery, I'm going to simply loop through instead of setting up a GlideAggregate.
        atfStepsGR.query();
        while (atfStepsGR.next()) {

            if (!this.state.targets.files.ATFTestSteps[atfStepsGR.sys_id.toString()])
                continue;

            this.activeTargetedAtfSteps[atfStepsGR.sys_id.toString()] = this.CODELESS; // Default

        }

        // Next, scan white-box (scripted) tests, and update the state of those steps in the active
        // targeted list. We want to differentiate between black-box codeless and white-box scripted 
        // tests. We want to count lines of test code. Make sure we are counting the same things
        // as the standard lines of code count.

        // AST walk handlers
        var atfScriptHandlers = {
            CallExpression: Scanner.callExpressionHandlerATF,
            VariableDeclarator: Scanner.variableDeclaratorHandlerATF,
            AssignmentExpression: Scanner.assignmentExpressionHandlerATF,
            FunctionDeclaration: Scanner.statementHandlerATF,
            FunctionExpression: Scanner.statementHandlerATF,
            ExpressionStatement: Scanner.statementHandlerATF,
            BlockStatement: Scanner.statementHandlerATF,
            IfStatement: Scanner.statementHandlerATF,
            LabeledStatement: Scanner.statementHandlerATF,
            BreakStatement: Scanner.statementHandlerATF,
            ContinueStatement: Scanner.statementHandlerATF,
            WithStatement: Scanner.statementHandlerATF,
            SwitchStatement: Scanner.statementHandlerATF,
            ReturnStatement: Scanner.statementHandlerATF,
            ThrowStatement: Scanner.statementHandlerATF,
            TryStatement: Scanner.tryStatementHandlerATF,
            WhileStatement: Scanner.statementHandlerATF,
            DoWhileStatement: Scanner.statementHandlerATF,
            ForStatement: Scanner.statementHandlerATF,
            ForOfStatement: Scanner.statementHandlerATF,
            LetStatement: Scanner.statementHandlerATF,
            DebuggerStatement: Scanner.statementHandlerATF
        };

        // Tests (sys_atf_test) are made up of Test Steps (sys_atf_step). The Steps are defined by 
        // a Test Step Config record (sys_atf_step_config) which consists of a set of 
        // Input Variables (atf_input_variable) and Output Variables (atf_output_variable),
        // which define what each step expects for configuration and results, which
        // can be passed to subsequent steps. 
        // For scripted test steps, those Input Variables will delare that a script must
        // be defined. Each atf_input_variable that delares a script will correspond to 
        // a sys_variable_value associated with the sys_atf_step that contains the actual 
        // test script. This is the script that will test library functions (Script Include and global
        // business rules). 
        // 
        // Since all we care about is scripted tests, we can start by finding all the Input Variables
        // defined to be scripts, and work our way back to the sys_variable_values that hold 
        // the scripts. We don't actually care what test step, or test for that matter, the script
        // in the sys_variable_value belongs to. We are just looking for code that executes
        // calls against library methods. 
        // 
        // So, find all ATF configuration input variables of script type (script and script_plain currently.)
        var atfScriptTypesGR = new GlideRecord("atf_input_variable");
        atfScriptTypesGR.addActiveQuery();
        atfScriptTypesGR.addEncodedQuery("internal_typeLIKEscript");
        atfScriptTypesGR.query();
        while (atfScriptTypesGR.next()) {



            this.state.currentScope = "global";

            // We need the actual name of the scope (not it's id), because
            // we will use it as a method call prefix eventually.
            var scopeGR = new GlideRecord("sys_scope");
            if (scopeGR.get(atfScriptTypesGR.sys_scope)) {
                this.state.currentScope = scopeGR.scope.toString();
            }

            // Find actual test step input variables that are configured as one of these script types, and scan ...
            var atfScriptsGR = new GlideRecord("sys_variable_value");
            atfScriptsGR.addQuery("document", "sys_atf_step");
            atfScriptsGR.addQuery("variable", atfScriptTypesGR.sys_id);
            atfScriptsGR.query();
            while (atfScriptsGR.next()) {

                // We could check if each step actually has any script in it,
                // but we don't need to since we use the raw LinesOfTestCode for our
                // test metrics
                // this.state.has_script = false;

                // document_key is the sys_id of the test step, given that the document is a sys_atf_step.
                if (!this.activeTargetedAtfSteps[atfScriptsGR.document_key.toString()])
                    continue;

                this.activeTargetedAtfSteps[atfScriptsGR.document_key.toString()] = this.SCRIPTED; // changing from codeless

                // The script is in the value field of an input variable. Since there is no name
                // for the input variable, we will track it by GUID
                this._scanAtfScript(atfScriptsGR, "document_key", "value", atfScriptHandlers);

                // We could check for this.state.has_script == true, but we don't use it. If there
                // are empty test steps, that will be reflected in the aggregate LinesOfTestCode number
            }
        }

        for (var i in this.activeTargetedAtfSteps) {

            //
            // Save off ATF Status and inspecable steps
            // 

            if (this.activeTargetedAtfSteps[i] == this.SCRIPTED) {

                this.stats.ActiveScriptedSteps++;
                if (state.stats.inspectableLists.active) {
                    state.stats.inspectableLists.whiteBoxTests.push(i);
                }
            }
            else {
                this.stats.ActiveCodelessSteps++;
                if (state.stats.inspectableLists.active) {
                    state.stats.inspectableLists.blackBoxTests.push(i);
                }
            }
        }
    },



    _scanAtfScript: function (gr, name_field, script_field, ast_walk_handlers) {
        try {

            var code = gr[script_field].toString();

            if (code.length <= 0) {
                gs.info("No script in " + gr[name_field]);
                return;
            }

            var tree = x_snc_dk_acorn.ASTree.parse(code);  // Make the Abstract Syntax Tree

            // For dev purposes
            //if (this.state.dumpTree) {
            //	gs.info(JSON.stringify(tree).replace(/,/g, '\n'));
            //}
            x_snc_dk_acorn.ASTree.walk(tree, ast_walk_handlers, null, this.state);

            // Be explicit (probably not necessary)
            code = 0;
            tree = 0;
        }
        catch (e) {
            gs.error("_scanAtfScript: MAJOR processing exception on " + gr[name_field] + ". " + e);
            // break;
        }
    },



    processPackagedAppFiles: function (format, query) {

        this.state.processingPackages = true;
        this.state.format = format;
        this.state.query = query;

        var packageRecordName = "";
        switch (format) {
            case "remote_update_set":
                packageRecordName = "sys_remote_update_set";
                break;
            case "update_set":
                packageRecordName = "sys_update_set";
                break;
            case "scope":
                packageRecordName = "sys_scope";
                break;
            case "plugin":
                packageRecordName = "v_plugin";
                break;
            default:
                gs.error("Invalid accelerator packaging format. Aborting!");
                throw "exit";
        }

        try {

            // Progress bar and random selection initialization 
            // Get a count of all the packaged items we will have to process for the progress bar
            // In addition, identify the number of items in each random selection
            // group so that an array of random selections can be made which will
            // be used to select those random victims during processing. I.e., we
            // need the range to feed the random number generator.
            var gr = new GlideRecord(packageRecordName);
            gr.addEncodedQuery(query);
            gr.query();
            while (gr.next()) {
                switch (format) {
                    case "remote_update_set":
                    case "update_set":

                        var updateCount = new GlideAggregate("sys_update_xml");
                        updateCount.addAggregate("COUNT");
                        updateCount.addQuery("update_set", gr.sys_id);
                        updateCount.addQuery("action", "INSERT_OR_UPDATE");
                        updateCount.query();
                        if (updateCount.next()) {
                            this.itemsToProcess += parseInt(updateCount.getAggregate("COUNT"));
                        }
                        break;
                    case "scope":
                        break;
                    case "plugin":
                        break;
                    default:
                }
            }

            // 
            // Transition to Running state
            //

            if (this.state.resultsGR) {
                this.state.status = "Running";
                this.state.resultsGR.status = this.state.status;
                //this.state.resultsGR.setWorkflow(false);
                this.state.resultsGR.update();
            }


            gr.initialize();
            gr.addEncodedQuery(query);
            gr.orderBy("sys_id"); // This is for the checksum calculation
            gr.query();
            while (gr.next()) {
                switch (format) {
                    case "remote_update_set":
                    case "update_set":
                        this._processUpdateSet(gr.sys_id.toString());
                        break;
                    case "scope":
                        this._processScope(gr);
                        break;
                    case "plugin":
                        this._processPlugin(gr);
                        break;
                    default:
                        gs.error("Invalid accelerator packaging format. Ignoring!");
                }
            }
        }
        catch (e) {
            gs.error("processPackagedAppFiles: Unhandled exception during package scans. Aborting. Msg: " + e);
            this.state.status = "Error";
            this.state.resultsGR.update();

            throw "exit";
        }

        try {
            this._scanTestCoverage();
        }
        catch (e) {
            gs.error("processPackagedAppFiles: Unhandled exception during ATF scans. Aborting. Msg: " + e);
            this.state.status = "Error";
            this.state.resultsGR.update();
            throw "exit";
        }


        // TODO - Add the Pass Fail logic
        this.state.status = "Complete";
    },

    _processUpdateSet: function (update_set_id) {
        var gr = new GlideRecord("sys_update_xml");
        gr.addQuery("update_set", update_set_id);
        gr.addQuery("action", "INSERT_OR_UPDATE");
        gr.orderBy("sys_id"); // This is for checksum calculation
        gr.query();
        while (gr.next()) {

            var payload = gr.payload.toString();

            // This is a cumulative signature across all payloads. Ensure they are 
            // always ordered consistently! 
            this.stats.checksum = Checksum.crc32(payload, this.stats.checksum);

            var fileType = gr.type.toString();
            if ("Workflow" == fileType) {
                // TODO: this is involved!
                // This payload contains a variety of record meta, and depends on other meta info
                // to convert the XML to JSON, and walk it to find information about
                // the values, and then go out to definitions for those values in different records since
                // that is the only way to figure out what they are actually for. That is the only way to determine what
                // each value actually is (script for an if statement, a user approval, a script activity,...)

                // Format of a Workflow update payload
                // -----------------------------------------
                // All of the elements of a workflow are included in the update set
                // associated with a wf_workflow_version application file:
                //  - wf_workflow_version
                //  - wf_workflow (this is sys_metadata)
                //  - wf_condition (one for workflow, and one for each activity)
                //  - wf_activity
                //  - sys_variable_value 
                //  - wf_transition
                //  - wf_estimated_runtime_config
                //
                // There are many sets of a wf_activity and its associated sys_variable_values.
                // They are all in order. The values will follow the activity immediately. 
                // Grouping is relevant because we count how many activities have script.
                // Even though we know apriori if an activity has scripted variables,
                // we don't know if they actually have script until we scan them. They
                // may be empty or defaulted to nothing but comments. Therefore, we have
                // to scan all of the variables assocated with an activity as a 
                // unit to determine if the activity is actually scripted.
                //
                // Inspection processing
                // -----------------------------------------
                //  - Each wf_activity needs to be accounted for
                //  - Each scripted sys_variable_value needs to be scanned for metrics
                //  - A wf_activity is active if it's workflow is "published"
                //  - A wf_activity is scripted if one of its variables is scripted, AND
                //    there is actually some live script in it
                //
                // We will use XMLDocument2 to parse the xml. It is good at iterating
                // over a particular node type. Iterating of variables for a particular
                // activity, not so much. Therefore, we will process in two phases.
                // The first will go through all activities, logging each one that is found. 
                // The second will go through all variables, scanning for metrics,
                // and updating the activity log when a script is found. 
                //
                // Note that there appears to be a bug in the update set payload 
                // generator? I see duplicates for variables in many examples
                // Se, we can't trust this stuff. Better track info for each sys_id
                // in a hash object.
                //
                //
                // By definition, the workflow, activities and variables in this update set
                // record are related. This makes checking for active simple. 

                var payloadXML = new XMLDocument2();
                payloadXML.parseXML(payload);

                // Active check
                if (payloadXML.getNodeText("/record_update/wf_workflow_version/published") != true)
                    continue;

                var scope = payloadXML.getNodeText("/record_update/wf_workflow/sys_scope");

                var currentNode = payloadXML.getFirstNode("/record_update/wf_activity/sys_id");
                while (currentNode) {

                    Inspector.examineWorkflowActivity(this.stats, this.state, currentNode.getNodeName(), scope);
                    currentNode = payloadXML.getNextNode(currentNode);
                }

                currentNode = payloadXML.getFirstNode("/record_update/sys_variable_value");
                while (currentNode) {

                    var iter = currentNode.getChildNodeIterator();
                    var n = 0;
                    var isScript = false;
                    var scriptString = "";
                    var documentKey = "";
                    var varDictionaryId = "";
                    var varId = "";
                    while (iter.hasNext()) {
                        n = iter.next();
                        if (n.getNodeName() == "variable") {
                            if (Inspector.isVariableUnderInspection(n.getTextContent())) {
                                isScript = true;
                                varDictionaryId = n.getTextContent();
                            }
                        }
                        else if (n.getNodeName() == "sys_id") {
                            varId = n.getTextContent();
                        }
                        else if (n.getNodeName() == "document_key") {
                            documentKey = n.getTextContent();
                        }
                        else if (n.getNodeName() == "value") {
                            scriptString = n.getTextContent();
                        }
                    }
                    if (isScript) {
                        Inspector.examineVariable(this.stats, this.state, scriptString,
                            documentKey, varDictionaryId, varId);
                    }

                    currentNode = payloadXML.getNextNode(currentNode);
                }

            }
            else {

                Inspector.examinePayload(this.stats, this.state, payload);
            }

            this._checkProgress();
        }
    },

    _checkProgress: function () {

        if (this.itemsToProcess <= 0)
            return;

        this.itemsProcessed++;

        var now = new GlideDateTime(gs.hoursAgo(0)).getNumericValue();
        if (now > this.progressUpdateMilestone) {

            this.state.resultsGR.progress = (100.0 * this.itemsProcessed /
                this.itemsToProcess).toFixed(0);
            //this.state.resultsGR.setWorkflow(false); 
            this.state.resultsGR.update();

            this.progressUpdateMilestone = now + this.progressUpdatePeriod;
        }
    },

    _processPlugin: function (pluginGR) {
        // TODO - FIXME
        // This needs to be updated and tested

        var appFileGR = new GlideRecord("sys_metadata");

        //
        // Copied from "Plugin Files" Relationship
        //

        // A plugin is either global, or a scoped app.
        // In either case, the Application File's "Package" field will reference
        // a Package record. If Global, the Package record will actually be a 
        // get the package sys_id
        var packageID = "-1";
        var scopeName = !pluginGR.scope.nil() ? pluginGR.scope.toString() : 'global';

        // check if the source is actually a scoped application
        // if so the packageID is the scopeID
        var scope = new GlideRecord('sys_scope');
        if (scopeName !== 'global' && scope.get('scope', scopeName)) {
            packageID = scope.getUniqueValue();
            var files = new GlideRecord('sys_metadata');
            files.addQuery('sys_package', packageID);
            files.addQuery('sys_customer_update', true);
            files.query();
            // exclude customer files if any
            var customerFileIds = new global.UpdateVersionAPI().getCustomerFileIds(files);
            if (customerFileIds.length > 0)
                appFileGR.addQuery('sys_id', 'NOT IN', customerFileIds);
        } else {
            var plugin = new GlideRecord("sys_plugins");
            if (plugin.get("source", pluginGR.id.toString()))
                packageID = plugin.getUniqueValue();
        }

        appFileGR.addQuery("sys_package", packageID);
        // TODO add activity query
        appFileGR.query();
        while (appFileGR.next()) {

            var api = null;
            var fileType = appFileGR.sys_class_name.toString();
            if (fileType == "Script Include" && appFileGR.api_name)
                api = appFileGR.api_name.toString();

            // TODO active checks for special cases
            if (gr.sys_class_name == "wf_activity") {
                if (wfa.workflow_version) {
                    if (wfa.workflow_version.published) {
                        this.stats.inventory.wf_activity.count++;
                        if (!wfa.workflow_version.workflow ||
                            !wfa.workflow_version.workflow.sys_scope ||
                            wfa.workflow_version.workflow.sys_scope == "global") {
                            this.stats.inventory.wf_activity.global_count++;
                        }
                    }
                }
            }

        }
    },

    _processScope: function (scopeGR) {
        // TODO - FIXME
        // This needs to be updated and tested

        var appFileGR = new GlideRecord("sys_metadata");
        appFileGR.addQuery("sys_scope", scopeGR.sys_id.toString());
        appFileGR.query();
        while (appFileGR.next()) {

            var api = null;
            var fileType = appFileGR.sys_class_name.toString();
            if (fileType == "Script Include" && appFileGR.api_name)
                api = appFileGR.api_name.toString();

        }
    },

    type: 'Main'
};

]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>dave.knight</sys_created_by>
        <sys_created_on>2018-08-06 03:43:03</sys_created_on>
        <sys_customer_update>true</sys_customer_update>
        <sys_id>721d1ebc4f37df40ea338e328110c718</sys_id>
        <sys_mod_count>336</sys_mod_count>
        <sys_name>Main</sys_name>
        <sys_package display_value="Validator" source="x_snc_dk_validator">65ec1ebc4f37df40ea338e328110c714</sys_package>
        <sys_policy/>
        <sys_replace_on_upgrade>false</sys_replace_on_upgrade>
        <sys_scope display_value="Validator">65ec1ebc4f37df40ea338e328110c714</sys_scope>
        <sys_update_name>sys_script_include_721d1ebc4f37df40ea338e328110c718</sys_update_name>
        <sys_updated_by>dave.knight</sys_updated_by>
        <sys_updated_on>2018-12-17 16:16:41</sys_updated_on>
    </sys_script_include>
</record_update>
