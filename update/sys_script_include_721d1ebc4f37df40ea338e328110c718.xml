<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>public</access>
        <active>true</active>
        <api_name>x_snc_dk_validator.Main</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <name>Main</name>
        <script><![CDATA[var Main = Class.create();

/*

Usage
_______

var validator = new x_snc_dk_validator.Main("Scan description", "update_set", "state=complete");
validator.scanScriptIncludes();
validator.scanTestCoverage();
validator.logStats();


Design Notes
--------------

* Logging Statistics

During "targeted" script scanning, detect all variable declarations and assignments of "tracked" classes, 
and their function nesting depth so we can deal with function scoping and variable overrides, 
and record the "Class" of object those variables represent. A tracked class is one that relates to logging.
A targeted script will be in the package(s) identified during Main initialization. 

The Class name saved will be fully qualified, i.e. <scope>.<Class>. Save this name in state.variables.<function_depth>.<variable_name> = <scope>.<class>. This information will be used to identify method calls to tracked objects
such as "gs" or "GSLog". The global scope is "global". 

* White Box Test Statistics

During targeted script scanning, detect all function declarations, and record their fully qualified method name,
i.e. <scope>.<Class>.<function_property>. Save this information in state.targets.methods.<method>

The method names in state.targets.methods will indicate what is eligable for a scripted ATF test.
The value of each state.targets.methods.<method_name> will be the number of ATF calls to that method.

During testCoverage scanning, detect all variable declarations and assignments, at their function nesting
depth, and record the Class of object those variables represent. This will be a fully qualified class, 
i.e. <scope>.<Class_name>. Save this information in 
state.variables.<function_depth>.<variable_name> = <scope>.<Class>. This information will be used to 
identify calls to targeted functions. The call is identified as <scope>.<Class>.<function>. If
the scope is not used as a class prefix in the ATF source code, add the implied scope, 
which is the scope of the ATF test.

*/

// These are the "classes" we are interested in tracking in order to gather call statistics
// other than ATF. for now, it is classes associated with logging. TODO make it configurable.
// Side Note - all classes (script includes actually) are targeted when processing ATF scripts. 
// We want to track all calls, to any Script Include method, since most will be executing tests.
// This data structure is for everything except ATF.
trackedClasses = {
	gs : 1
};
trackedClasses["global.GSLog"] = 1; // The dot causes issues with static initialization

Main.prototype = {
	
	
	initialize: function(desc, format, query, dump_tree) {
		
		this.startedAt = gs.hoursAgo(0);
		
		this.description = desc;
		this.format = format;
		this.query = query;
		this.dumpTree = false;
		this.FileCount = 0;
		
		
		// Stats generated by RegEx scans or other non AST walking logic
		this.CodeCharCount = 0;
		this.CommentCharCount = 0;
		this.NoCommentFileCount = 0;
		this.activeTargetedAtfSteps = {};
		this.codelessAtfStepCount = 0;
		this.scriptedAtfStepCount = 0;
		this.totalTestableFileCount = 0; // A bit subjective, look in _logTheTargetAppFile
		
		this.isMainLimitedToTargets = false;		
		
		// Stats generated by AST scan
		// NOTICE! Any of the helpers in this file that collect stats must have that stat initialized
		// in this state object!
		// Same holds for everything else, like the targets
		this.state = {
			stats: {
				ScriptSize: 0, // The number of nodes in the script's syntax tree
				LinesOfCode: 0,  // Javascript statements, variable declarations, assignment expressions and function calls
				DebugCallCount: 0,
				LogCallCount: 0,
				GlobalLogCallCount: 0,
		
				// Statement counts
				BlockStatementCount: 0,
				ExpressionStatementCount: 0,
				IfStatementCount: 0,
				LabeledStatementCount: 0,
				BreakStatementCount: 0,
				ContinueStatementCount: 0,
				WithStatementCount: 0,
				SwitchStatementCount: 0,
				ReturnStatementCount: 0,
				ThrowStatementCount: 0,
				TryStatementCount: 0,
				WhileStatementCount: 0,
				DoWhileStatementCount: 0,
				ForStatementCount: 0,
				ForOfStatementCount: 0,
				LetStatementCount: 0,
				DebuggerStatementCount: 0,
		
				FunctionDeclarationCount: 0,
				FunctionExpressionCount: 0,
				VariableDeclaratorCount: 0
			},
			targets: {
				files: {
					ScriptIncludes: {},
					BusinessRules: {},
					ScriptActions: {},
					DynamicFilters: {},
					OutboundEmailScript: {},
					InboundEmailScript: {},
					Relationships: {},
					Processors: {},
					UIMacros: {},
					UIPages: {},
					UIScripts: {},
					ClientScripts: {},
					FixScripts: {},
					DictionaryOverrides: {},
					Dictionary: {},
					ATFTestSteps: {},
					ATFTests: {}
				},
				classes: {},
				methods: {}
			},
			variables: {},
			block_scope: {},
			function_depth: 0,
			block_depth: 0,
			CurrentFile: "",
			CurrentScope: ""
		};	
		
		this.state.variables[0]={}; // CHG1
		this.state.block_scope[0] = {};
		
		if (format && query) {
			// This will restrict the scan and analysis to just the application files
			// identified by the query
			this._logTargetedAppFiles(format, query);
		}
		if (dump_tree)
			this.dumpTree = true;
		
	},
	
	logStats: function () {
		
		
		// Staging variables for database persistence.
		// The datastore field labels match the labels that are printed out by gs.info below.
		// Why? because it was easy for me to building the DB table. Live with it. 
		// Keep it that way, and things will continue to work fine.
		// If one of the datastore labels doesn't match one of the this.[...] variable names,
		// create a temporary variable here that does, and we will set it before getting
		// to the DB dump
		var output = {
			 ModifiedFileCount: 0,
			 ModifiedMethodCount: 0,
			 ScriptTestPercentage: 0.0,
			 CodelessTestRatio: 0.0,
			 CommentPercentage: 0.0,
			 LogPercentage: 0.0,
			 DebugPercentage: 0.0,
			 ExceptionPercentage: 0.0,
			 NumberOfScriptsTested: 0,
			 NumberOfActiveScriptedTestSteps: 0,
			 NumberOfActiveCodelessTestSteps: 0,
			 fileCounts: {}
		};
		
		if (this.CodeCharCount <= 0) {
			return;
		}
		
		//
		// Human readable
		//
		
		var targetedMethodCount = 0;
		var testedMethodCount = 0;
		if (this.isMainLimitedToTargets) {
			gs.debug("Targeted Methods for ATF Test Execution Statistics");
			gs.debug("--------------------------------------------------------------");
			for (var q in this.state.targets.methods) {
				targetedMethodCount++;
				gs.debug(q);
				if (this.state.targets.methods[q] > 0)
					testedMethodCount++;
			}
		}
		
		gs.info("");
		gs.info("Risk Factors");
		gs.info("--------------------------------------------------------------");
		output.ModifiedFileCount = this.FileCount; // for DB load to come
		gs.info("ModifiedFileCount: " + this.FileCount);
		if (this.isMainLimitedToTargets) {
			gs.info("ModifiedMethodCount:" + targetedMethodCount);
			output.ModifiedMethodCount = targetedMethodCount; // for DB load to come
		}
		gs.info("LinesOfCode:" + this.state.stats.LinesOfCode);
		gs.info("ScriptSize:" + this.state.stats.ScriptSize);
		
		gs.info("");
		gs.info("Risk Mitigation Factors");
		gs.info("--------------------------------------------------------------");
		if (targetedMethodCount > 0) {
			output.ScriptTestPercentage = ((testedMethodCount / targetedMethodCount) * 100.0).toFixed(2);
			gs.info("ScriptTestPercentage: " + output.ScriptTestPercentage + "%"); 
		}
		if (this.totalTestableFileCount > 0) {
			output.CodelessTestRatio = (this.codelessAtfStepCount / this.totalTestableFileCount).toFixed(2);
			gs.info("CodelessTestRatio: " + output.CodelessTestRatio); 
		}
		output.CommentPercentage = ((this.CommentCharCount / this.CodeCharCount) * 100.0).toFixed(2);
		gs.info("CommentPercentage: " + output.CommentPercentage + "%");
		if (this.state.stats.LinesOfCode > 0) {
			output.LogPercentage = ((this.state.stats.LogCallCount / this.state.stats.LinesOfCode) * 100.0).toFixed(2);
			gs.info("LogPercentage: " + output.LogPercentage + "%");
			output.DebugPercentage = ((this.state.stats.DebugCallCount / this.state.stats.LinesOfCode) * 100.0).toFixed(2);
			gs.info("DebugPercentage: " + output.DebugPercentage + "%");
			output.ExceptionPercentage = ((this.state.stats.TryStatementCount / this.state.stats.LinesOfCode) * 100.0).toFixed(2);
			gs.info("ExceptionPercentage: " + output.ExceptionPercentage + "%");
		}
		else {
			gs.info("No executable lines of code scanned. Nothing to report on log, debug and exception handling percentages.");
		}
		
		if (this.isMainLimitedToTargets) {
			gs.info("");
			gs.info("Raw Test and Logging Data:");
			gs.info("--------------------------------------------------------------");
			output.NumberOfScriptsTested = testedMethodCount;
			gs.info("NumberOfScriptsTested: " + testedMethodCount);
			output.NumberOfActiveScriptedTestSteps = this.scriptedAtfStepCount;
			gs.info("NumberOfActiveScriptedTestSteps: " + this.scriptedAtfStepCount);
			output.NumberOfActiveCodelessTestSteps = this.codelessAtfStepCount;
			gs.info("NumberOfActiveCodelessTestSteps: " + this.codelessAtfStepCount);
			gs.info("LogCallCount: " + this.state.stats.LogCallCount);
			gs.info("DebugCallCount: " + this.state.stats.DebugCallCount);
		}
		
		gs.info("");
		gs.info("Raw Source Code Data:");
		gs.info("--------------------------------------------------------------");
		gs.info("NoCommentFileCount: " + this.NoCommentFileCount);
		for (var p in this.state.stats) {
			gs.info(p + ": " + this.state.stats[p]);
		}
		
		if (this.isMainLimitedToTargets == true) {
			gs.info("");
			gs.info("Targeted Application File Counts:");
			gs.info("--------------------------------------------------------------");
			for (var r in this.state.targets.files) {
				var i = 0;
				for (var s in this.state.targets.files[r]) {
					i++;
				}
				output.fileCounts[r] = i; // For DB load
				gs.info(r + ": " + i);
			}
		}
		
		//
		// Dump to database
		//
		
		if (gs.tableExists("x_snc_dk_valid_res_metrics")) {
			// The Validator Results app is installed.
			// Save our results to it.
			
			var store = new GlideRecord("x_snc_dk_valid_res_metrics");
			var fields = new GlideRecord('sys_dictionary');
			fields.addEncodedQuery("name=x_snc_dk_valid_res_metrics^elementNOT LIKEsys_^element!=transmitted^element!=started^element!=instance^element!=scan_duration^element!=number^internal_type!=collection");
			fields.query();
			while(fields.next())
			{
				
				
				// The labels of the fields in the table were configured to match
				//	the variable names in here
				if (output[fields.column_label]) {
					store[fields.element] = output[fields.column_label];
				}
				else if (output.fileCounts[fields.column_label]) {
					store[fields.element] = output.fileCounts[fields.column_label];
				}
				else if (this[fields.column_label]) {
					store[fields.element] = this[fields.column_label];
				}
				else if (this.state.stats[fields.column_label]) {
					store[fields.element] = this.state.stats[fields.column_label];
				}
				else if (this.state.targets.files[fields.column_label]) {
					store[fields.element] = this.state.targets.files[fields.column_label];
				}		
			}	
			store.instance = "https://" + gs.getProperty("instance_name") + ".service-now.com";
			store.started = this.startedAt;
			var endedAt = gs.hoursAgo(0);
			
			var durationMS = new GlideDateTime(endedAt).getNumericValue() - 
				new GlideDateTime(this.startedAt).getNumericValue();
			store.scan_duration = new GlideDuration(durationMS);
			gs.info("Duration (min): " + durationMS / (1000 * 60));
			store.description = this.description;
			store.package_format = this.format;
			store.package_query = this.query;
											   
			store.insert();
		}	
	},
	
	
	
	scanScriptIncludes: function () {
		
		// AST walk handlers
		var scriptIncludeHandlers = {
			FunctionDeclaration: functionDeclarationHandler,
			FunctionExpression: functionExpressionHandler,
			CallExpression: callExpressionHandler,
			AssignmentExpression: assignmentExpressionHandler,
			MemberExpression: memberExpressionHandler,
			VariableDeclarator:  variableDeclaratorHandler,
			ExpressionStatement: statementHandler,
			BlockStatement : statementHandler,
			IfStatement : statementHandler,
			LabeledStatement : statementHandler,
			BreakStatement : statementHandler,
			ContinueStatement : statementHandler,
			WithStatement : statementHandler,
			SwitchStatement : statementHandler,
			ReturnStatement : statementHandler,
			ThrowStatement : statementHandler,
			TryStatement : tryStatementHandler,
			WhileStatement : statementHandler,
			DoWhileStatement : statementHandler,
			ForStatement : statementHandler,
			ForOfStatement : statementHandler,
			LetStatement : statementHandler,
			DebuggerStatement : statementHandler
		};
		
		var gr = new GlideRecord("sys_script_include");
		gr.addActiveQuery();
		//gr.addQuery("sys_id", "404098104fc4630056faac118110c7e8"); // TEST x_snc_dk_validator.Main
		//gr.addQuery("sys_id", "a99882044f3f5f40ea338e328110c7a9"); // ACORN
		//gr.addQuery("sys_id", "1737951c4f086300ea338e328110c7ff"); // Test dummmy
		
		gr.query();
		while (gr.next()) {	
			if (this.isMainLimitedToTargets && !this.state.targets.files.ScriptIncludes[gr.sys_id.toString()])
				continue; // skip it if not targeted for analysis
			this.state.CurrentFile  = gr.api_name.toString(); // includes scope prefix and file name
			var i = this.state.CurrentFile.indexOf("."); // scope is always the prefix of the API
			this.state.CurrentScope = this.state.CurrentFile.substring(0,i);
						
			this._executeScanOverScript (gr, "name", "script", scriptIncludeHandlers);
		}
	},
	
	scanTestCoverage: function () {
		
		// States of our ATF tests. 
		var CODELESS = "codeless";
		var SCRIPTED = "scripted";
		
		if (!this.isMainLimitedToTargets) {
			gs.error("Usage error: You must define a package for test coverage analysis.");
			return;
		}
		
		// First, collect the ids of all active test scripts that were identified by the targeted
		// updates/pluggins. Some may not have been active. Default their type to codeless, even
		// though some may be scrpted. We will find the scripted ones shortly.
		var atfStepsGR = new GlideRecord("sys_atf_step");
		atfStepsGR.addQuery("active", true);
		atfStepsGR.addQuery("test.active", true);
		// Since I'm not sure how big the sys_id string can be before blowing up a GlideRecord
		// encodedQuery, I'm going to simply loop through instead of setting up a GlideAggregate.
		atfStepsGR.query();
		while (atfStepsGR.next()) {
			
			if (!this.state.targets.files.ATFTestSteps[atfStepsGR.sys_id])
				continue;
			
			this.activeTargetedAtfSteps[atfStepsGR.sys_id] = CODELESS; // Default
			
		}
				
		// Next, scan white-box (scripted) tests, and update the state of those steps in the active
		// targeted list. We want to differentiate between black-box codeless and white-box scripted 
		// tests
		
		// AST walk handlers
		var atfScriptHandlers = {
			CallExpression: callExpressionHandlerATF,
			VariableDeclarator:  variableDeclaratorHandlerATF,
			AssignmentExpression: assignmentExpressionHandlerATF
		};
		
		// Find all ATF configuration input variables of script type (script and script_plain currently.)
		var atfScriptTypesGR = new GlideRecord("atf_input_variable");
		atfScriptTypesGR.addActiveQuery();
		atfScriptTypesGR.addEncodedQuery("internal_typeLIKEscript");  
		atfScriptTypesGR.query();
		while (atfScriptTypesGR.next()) {
			
						
			this.state.CurrentScope = "global";
			var scopeGR = new GlideRecord("sys_scope");
			if (scopeGR.get(atfScriptTypesGR.sys_scope)) {
				this.state.CurrentScope = scopeGR.scope.toString();
			}
			
			// TEST
			// this.state.CurrentScope = "x_snc_dk_validator";
			
			// Find actual test step input variables that are configured as one of these script types, and scan ...
			var atfScriptsGR = new GlideRecord("sys_variable_value");
			atfScriptsGR.addQuery("document", "sys_atf_step");
			atfScriptsGR.addQuery("variable", atfScriptTypesGR.sys_id);
			// atfScriptsGR.addQuery("document_key", "6bac16114f771380ea338e328110c7c5"); // TEST STEP
			atfScriptsGR.query();
			while (atfScriptsGR.next()) {
				
				// document_key is the sys_id of the test step, given that the document is a sys_atf_step.
				if (!this.activeTargetedAtfSteps[atfScriptsGR.document_key])
					continue;
				
				this.activeTargetedAtfSteps[atfScriptsGR.document_key] = SCRIPTED; // changing from codeless
				
				// The script is in the value field of an input variable. Since there is no name
				// for the input variable, we will track it by GUID
			   this._executeScanOverScriptATF (atfScriptsGR, "document_key", "value", atfScriptHandlers);
			}
		}
		
		for (var i in this.activeTargetedAtfSteps) {
			
			if (this.activeTargetedAtfSteps[i] == SCRIPTED) 
				this.scriptedAtfStepCount++;
			else
				this.codelessAtfStepCount++;
		}
		

	},
	
	_executeScanOverScript: function (gr, name_field, script_field, ast_walk_handlers) {
		try {

			this.FileCount++;

			var code = gr[script_field].toString();
			this.CodeCharCount += code.length;
			if (code.length <= 0) {
				gs.info("No script in " + gr[name_field]);
				return;
			}

			var comments = code.match(/\/\*[\s\S]*?\*\/|\/\/.*/g);
			if (comments) {
				for (var k = 0; k < comments.length; k++) {
					this.CommentCharCount += comments[k].length;
				}
			}
			else {
				this.NoCommentFileCount++;
			}

			var tree = x_snc_dk_acorn.ASTree.parse(code);  // Make the Abstract Syntax Tree
			
			// For dev purposes
			if (this.dumpTree) {
				gs.info(JSON.stringify(tree).replace(/,/g, '\n'));
			}
			x_snc_dk_acorn.ASTree.walk(tree, ast_walk_handlers, null, this.state);

			// Be explicit (probably not necessary)
			code = 0;
			comments = 0;
			tree = 0;	
		}
		catch (e) {
			gs.error("MAJOR Processing exception in " + gr[name_field] + ". " + e);
			// break;
		}
	},
	
	_executeScanOverScriptATF: function (gr, name_field, script_field, ast_walk_handlers) {
		try {

			var code = gr[script_field].toString();
			
			if (code.length <= 0) {
				gs.info("No script in " + gr[name_field]);
				return;
			}
			
			var tree = x_snc_dk_acorn.ASTree.parse(code);  // Make the Abstract Syntax Tree
			
			// For dev purposes
			//if (this.dumpTree) {
			//	gs.info(JSON.stringify(tree).replace(/,/g, '\n'));
			//}
			x_snc_dk_acorn.ASTree.walk(tree, ast_walk_handlers, null, this.state);

			// Be explicit (probably not necessary)
			code = 0;
			tree = 0;	
		}
		catch (e) {
			gs.error("MAJOR ATF processing exception in " + gr[name_field] + ". " + e);
			// break;
		}
	},

	_logTargetedAppFiles: function (format, query) {
		
		this.isMainLimitedToTargets = true;
		
		var packageRecordName = "";
		switch (format) {
			case "remote_update_set":
				packageRecordName = "sys_remote_update_set";
				break;
			case "update_set":
				packageRecordName = "sys_update_set";
				break;
			case "scope":
				packageRecordName = "sys_scope";
				break;
			case "plugin":
				packageRecordName = "v_plugin";
				break;
			default:
				gs.error("Invalid accelerator packaging format. Aborting!");
				throw "exit";
		}
		
		var gr = new GlideRecord(packageRecordName);
		gr.addEncodedQuery(query);
		gr.query();
		while (gr.next()) {
			switch (format) {
			case "remote_update_set":
			case "update_set":
				this._logFromUpdate(gr.sys_id.toString());
				break;
			case "scope":
				this._logFromScope(gr);
				break;
			case "plugin":
				this._logFromPlugin(gr);
				break;
			default:
				gs.error("Invalid accelerator packaging format. Aborting!");
				throw "exit";
			}	
		}
	},
		
	_logFromUpdate: function (update_set_id) {
		var gr = new GlideRecord("sys_update_xml");
		gr.addQuery("update_set", update_set_id);
		gr.addQuery("action", "INSERT_OR_UPDATE");
		//gr.addQuery("type", "Script Include");
		gr.query();
		while (gr.next()) {
			
			if ("Workflow" == gr.type) {
				// TODO: this is involved!
				// This payload contains a variety of record meta, and depends on other meta info
				// To do this right is complicated. We will need
				// to convert the XML to JSON, and walk it to find information about
				// the values, and then go out to definitions for those values in different records since
				// that is the only way to figure out what they are actually for. That is the only way to determine what
				// each value actually is (script for an if statement, a user approval, a script activity,...)
				continue;
			}
			
			
			// Almost all XML update records have only one match for this tag.
			// However, a few have multiple, like ATF Test Steps and Workflows.  For now,
			// Pull off the first one, and ignore any others, so use a non-greedy expression
			// The capture group (the sys_id alone) will be in the 2nd spot in the array
			var payload = gr.payload.toString();
			var fileType = gr.type.toString();
			var id = payload.match(/<sys_id>(.+?)<\/sys_id>/);
			var api = null;
			if (fileType == "Script Include") {
				var x = payload.match(/<api_name>(.+?)<\/api_name>/); // Will be null if no api_name
				if (x)
					api = x[1];
			}
			this._logTheTargetAppFile(id[1], fileType, api);
		}
	},
	
	
	_logFromPlugin: function (pluginGR) {
	
		var appFileGR = new GlideRecord("sys_metadata");
	
		//
		// Copied from "Plugin Files" Relationship
		//
		
		// A plugin is either global, or a scoped app.
		// In either case, the Application File's "Package" field will reference
		// a Package record. If Global, the Package record will actually be a 
		// get the package sys_id
		var packageID = "-1";
		var scopeName = !pluginGR.scope.nil() ? pluginGR.scope.toString() : 'global';

		// check if the source is actually a scoped application
		// if so the packageID is the scopeID
		var scope = new GlideRecord('sys_scope');
		if (scopeName !== 'global' && scope.get('scope', scopeName)) {
			packageID = scope.getUniqueValue();
			var files = new GlideRecord('sys_metadata');
			files.addQuery('sys_package', packageID);
			files.addQuery('sys_customer_update', true);
			files.query();
			// exclude customer files if any
			var customerFileIds = new global.UpdateVersionAPI().getCustomerFileIds(files);
			if (customerFileIds.length > 0)
				appFileGR.addQuery('sys_id', 'NOT IN', customerFileIds);
		} else {
			var plugin = new GlideRecord("sys_plugins");
			if (plugin.get("source", pluginGR.id.toString()))
				packageID = plugin.getUniqueValue();
		}

		appFileGR.addQuery("sys_package", packageID);
		appFileGR.query();
		while (appFileGR.next()) {
			
			var api = null;
			var fileType = appFileGR.sys_class_name.toString();
			if (fileType == "Script Include" && appFileGR.api_name)
				 api = appFileGR.api_name.toString();
			this._logTheTargetAppFile(appFileGR.sys_id.toString(), fileType, api);
		
		}
	},
	
	_logFromScope: function (scopeGR) {
	
		var appFileGR = new GlideRecord("sys_metadata");
		appFileGR.addQuery("sys_scope", scopeGR.sys_id.toString());
		appFileGR.query();
		while (appFileGR.next()) {
			
			var api = null;
			var fileType = appFileGR.sys_class_name.toString();
			if (fileType == "Script Include" && appFileGR.api_name)
				 api = appFileGR.api_name.toString();
			this._logTheTargetAppFile(appFileGR.sys_id.toString(), fileType, api);
		
		}
	},
	
	_logTheTargetAppFile: function (fileSysId, fileType, api) {
		switch (fileType) {
			case "sys_script_include":
			case "Script Include":
				this.state.targets.files.ScriptIncludes[fileSysId] = 1;
				if (api)
					this.state.targets.classes[api] = 1; 
				break;
			case "sys_script":
			case "Business Rule":
				this.state.targets.files.BusinessRules[fileSysId] = 1;
				this.totalTestableFileCount++;
				break;
			case "sysevent_script_action":
			case "Script Action":
				this.state.targets.files.ScriptActions[fileSysId] = 1;
				break;
			case "sys_filter_option_dynamic":
			case "Dynamic Filter Options":
				this.state.targets.files.DynamicFilters[fileSysId] = 1;
				break;	
			case "sys_script_email":
			case "Notification":
				this.state.targets.files.OutboundEmailScript[fileSysId] = 1;
				break;
			case "sysevent_in_email_action":
			case "Inbound Email Actions":
				this.state.targets.files.InboundEmailScript[fileSysId] = 1;
				break;
			case "sys_relationship":
			case "Relationship":
				this.state.targets.files.Relationships[fileSysId] = 1;
				break;
			case "sys_processor":
			case "Processor":
				this.state.targets.files.Processors[fileSysId] = 1;
				break;		
			case "sys_ui_macro":
			case "Macro":
				this.state.targets.files.UIMacros[fileSysId] = 1;
				break;
			case "sys_ui_page":
			case "UI Page":
				this.state.targets.files.UIPages[fileSysId] = 1;
				break;
			case "sys_ui_script":
			case "UI Script":
				this.state.targets.files.UIScripts[fileSysId] = 1;
				break;
			case "sys_script_client":
			case "Client Script":
				this.state.targets.files.ClientScripts[fileSysId] = 1;
				this.totalTestableFileCount++;
				break;
			case "sys_script_fix":
			case "Fix Script":
				this.state.targets.files.FixScripts[fileSysId] = 1;
				break;
			case "sys_dictionary_override":
			case "Dictionary Entry Override":
				this.state.targets.files.DictionaryOverrides[fileSysId] = 1;
				break;
			case "sys_dictionary":
			case "Dictionary":
				this.state.targets.files.Dictionary[fileSysId] = 1;
				this.totalTestableFileCount++;
				break;
			
			// ATF tests
			case "Test Step":
			case "sys_atf_step":
				// ?We could pull scripts out? Value is in sys_variable_value record
				// First sys_id in test step is for the step itself. Others are for the variables.
				// Of course, this is handled by the caller, which uses a lazy RegEx fortunately.
				this.state.targets.files.ATFTestSteps[fileSysId] = 1;
				break;
			case "Test":
			case "sys_atf_test":
				this.state.targets.files.ATFTests[fileSysId] = 1;
				break;
				
			default:
				break;
			}
	},
	
	type: 'Main'
};


//
// Abstract Syntax Tree walk handers - which are callbacks passed to the AST walker 
// (These can't be in the Main class, since the this context is lost on the callback)
//

function statementHandler (node, state, ancestors) {
	
	state.stats[node.type + "Count"]++;
	state.stats.LinesOfCode++;
}

function functionDeclarationHandler (node, state, ancestors) {
	
	state.stats[node.type + "Count"]++;
	state.stats.LinesOfCode++;
	
	if (state.function_depth > 0) {
		// We only want to track function at the scope level, which are accessable 
		// from outside the scope (no embedded functions) TODO
		return;
	}
	
	try {	
		if (node.id.type == "Identifier") {
			
			var methodName = ""; 
			if (state.block_scope[1] && state.block_scope[1].script_class) {
				methodName = state.CurrentScope + state.block_scope[1].script_class + "." + node.id.name;
			}
			else {
				methodName = state.CurrentScope + "." + node.id.name;
			}
			state.targets.methods[methodName] = 0;
		}
	}
	catch (e) {
		gs.error("Error in functionDeclarationHandler: " + e + ". Node: " + JSON.stringify(node));
	}
}

function tryStatementHandler (node, state, ancestors) {
	
	state.stats.LinesOfCode++;
	
	try {
		// only count try/catch that does something in the catch
		if (node.handler.body.body)
			state.stats[node.type + "Count"]++;
		
	} catch (e) {
		gs.error(e);
	}
}

function variableDeclaratorHandler (node, state, ancestors) {
	
	// We are tracking defined, in scope variables that reference tracked objects defined in the
	// trackedClasses object above, what we will call "classes of interest".
	// When a variable is declared, it can be initialized directly with one of those classes of interest,
	// or it can be initialized indirectly, to another variable, which in turn references one of those classes of interest.
	// The state.variables.<function_depth>.<variable_name> object tracks those declarations. Each
	// property is the name of a defined variable, and the value is the class name.
	
	try {
		
		state.stats[node.type + "Count"]++;
		state.stats.LinesOfCode++;
		
		// gs.debug("Processing declaration at function depth " + state.function_depth + " in " +
		// JSON.stringify(node));
		
		if (node.type == "VariableDeclarator" &&
			node.id.type == "Identifier" &&
			node.init)
		{
			var detectedClass = 0;
			if (node.init.type == "NewExpression") {
				
				if (node.init.callee.type == "Identifier") {
				
					detectedClass = _getTrackedClass(node.init.callee.name, state);

				}
				else if (node.init.callee.type == "MemberExpression" &&
						node.init.callee.object.type == "Identifier" &&
						node.init.callee.property.type == "Identifier") {
				
					// Assume object is <scope> and poperty is <class>
					var qualifiedName = node.init.callee.object.name + "." + node.init.callee.property.name;
					detectedClass = _getTrackedClass(qualifiedName, state);

				}
			}
			else if (node.init.type == "Identifier") {
				
				detectedClass = _getTrackedClass(node.init.name, state);
				
			}
			
			if (detectedClass) {
				_insertClassVariable(node.id.name, detectedClass, state, ancestors);
			}
			
		}
	} catch (ex) {
		gs.error("Bad node syntax in VariableDeclaration. " + ex);
		gs.debug("Bad node: " + JSON.stringify(node));
	}
}

function memberExpressionHandler (node, state, ancestors) {
	// This callback locates the prototype and identifies the Script Includes Class.
	try {
		//state.stats.LinesOfCode++;
		if (node.property.type == "Identifier" &&
			node.property.name == "prototype") {
		
			var parent = ancestors[ancestors.length - 2];
			if (parent.type == "AssignmentExpression" &&
			   parent.left == node) {
				
				state.block_scope[state.block_depth].script_class = node.object.name;
		
			}		
		}	
	} catch (e) {
		gs.warn("Issue in memberExpressionHandler. " + e);
	}
}

function assignmentExpressionHandler (node, state, ancestors) {
	try {
		
		state.stats.LinesOfCode++;
		var detectedClass = 0;
		if (node.type == "AssignmentExpression" &&
			node.operator == "=") {
			
			// Look for variables assigned to a tracked class
			if (node.right.type == "Identifier" &&
				node.left.type == "Identifier") {
			
				detectedClass = _getTrackedClass(node.right.name, state);
			
				if (detectedClass) {
					_insertClassVariable(node.left.name, detectedClass, state, ancestors);
				}
			}
			
		}
		
	} catch (e) {
		gs.warn("Issue in assignmentExpressionHandler. " + e);
	}
}

function callExpressionHandler (node, state, ancestors) {
	
	try {
		state.stats.LinesOfCode++;
		if (node.callee.type == "MemberExpression" && node.callee.property.type == "Identifier") {
			
			if (node.callee.object.type == "Identifier") {
				
				if (_isThisObjectThisClass(node.callee.object.name, "gs", state))
					_callExpressionHandlerHelper("gs", node.callee.object.name,
				node.callee.property.name, state, ancestors);
				else if (_isThisObjectThisClass(node.callee.object.name, "global.GSLog", state))
					_callExpressionHandlerHelper("global.GSLog", node.callee.object.name,
				node.callee.property.name, state, ancestors);
				
			}
			else if (node.callee.object.type == "NewExpression" && node.callee.object.callee.type == "Identifier" ) {
				
				
				if (_isThisObjectThisClass(node.callee.object.callee.name, "gs", state))
					_callExpressionHandlerHelper("gs", node.callee.object.callee.name,
				node.callee.property.name, state, ancestors);
				else if (_isThisObjectThisClass(node.callee.object.callee.name, "global.GSLog", state))
					_callExpressionHandlerHelper("global.GSLog", node.callee.object.callee.name,
				node.callee.property.name, state, ancestors);
				
			}
		}
	}
	catch (e) {
		gs.error("Error in my callExpressionHandler: " + e + ". Node: " + JSON.stringify(node));
	}
}

function functionExpressionHandler (node, state, ancestors) {
	
	state.stats[node.type + "Count"]++;
	
	try {
		state.stats.LinesOfCode++;
		var methodName = 0; // fully qualifed function property being called, i.e scope.Class[.Property].function
		
		var parent = ancestors[ancestors.length - 2]; // DAK

		if (parent.type == "AssignmentExpression" && parent.operator == "=" &&
		   parent.left.type == "MemberExpression" && parent.left.property.type == "Identifier") {
			// We are assigning a function to an object. The function name will be in
			// the left side MemberExpression property. The object itself will be in the left
			// side MemberExpression object. However, the object itself may be compound, i.e.
			// it isn't a simple identifier, it is another MemberExpression, with an Object.Property pair. 
			// Need to dive recursively to get the entire object name (may be a long dot walk)
			var fullObjectName = _fullObjectName(parent.left.object); 
			if (fullObjectName) {
				methodName = state.CurrentScope  + "." + fullObjectName + "." + parent.left.property.name;
			}
			else {
				methodName = state.CurrentScope + "." + parent.left.property.name;
			}
		}
		else if (parent && parent.type == "Property" && parent.key.type == "Identifier") {
			// We are a function property inside another object. What that object is is tracked by 
			// state.block_scope
			
			var methodCallName = parent.key.name;
			if (state.block_scope[1] && state.block_scope[1].script_class) {
				methodName = state.CurrentScope + "." + state.block_scope[1].script_class + "." + methodCallName;
			}
			else {
				methodName = state.CurrentScope + "." + methodCallName;
			}
		}
		if (methodName) {
			state.targets.methods[methodName] = 0;
		}
		
	}
	catch (e) {
		gs.error("Error in functionExpressionHandler: " + e + ". Node: " + JSON.stringify(node));
	}
}

//
// ATF Callback methods
//

function variableDeclaratorHandlerATF (node, state, ancestors) {
	
	// We are tracking all defined in scope variables in ATF test scripts that reference a targeted Script Include.
	// When a variable is declared, it can be initialized directly with a targeted Script Include class,
	// or it can be initialized indirectly, to another variable, which in turn references one of those tracked classes.
	// The state.variables.<function_depth>.<class_of_interest> object tracks those declarations. Each
	// property is an array of all the declared variables that refer to that particular targeted class.
	// The state.variables.<function_depth>.<variable_name> object tracks those declarations. Each
	// property is the name of a defined variable, and the value is the class name.
	
	try {
		
		//gs.debug("Processing ATF declaration at function depth " + state.function_depth + " in " +
		//JSON.stringify(node));
		
		if (node.type == "VariableDeclarator" &&
			node.id.type == "Identifier" &&
			node.init)
		{
			var detectedClass = 0;
			if (node.init.type == "NewExpression") {
				if (node.init.callee.type == "Identifier") {
					
					detectedClass = _getTargetedClass(node.init.callee.name, state);
				}
				else if (node.init.callee.type == "MemberExpression" &&
						node.init.callee.object.type == "Identifier" &&
						node.init.callee.property.type == "Identifier") {
					
					// callee.object.name should be scope. callee.property.name should be class.
					detectedClass = _getTargetedClass(node.init.callee.object.name + "." + 
													  node.init.callee.property.name , state);
				}
			}
			else if (node.init.type == "Identifier") {
				
				detectedClass = _getTargetedClass(node.init.name, state);
				
			}
			
			if (detectedClass) {
				_insertClassVariable(node.id.name, detectedClass, state, ancestors);
			}
			
		}
	} catch (ex) {
		gs.error("variableDeclaratorHandlerATF: Bad node syntax in VariableDeclaration. " + ex);
		gs.debug("variableDeclaratorHandlerATF: Bad node - " + JSON.stringify(node));
	}
}

function callExpressionHandlerATF (node, state, ancestors) {
	
	try {
		if (node.callee.type == "Identifier") {
			_callExpressionHandlerHelperATF(null,
						node.callee.name, state, ancestors);
		}
		else if (node.callee.type == "MemberExpression" && node.callee.property.type == "Identifier") {
			// The property is our function name
			
			if (node.callee.object.type == "Identifier") {
				// The object could be a class, or a scope if there is no class ("global" level method of scope)
				_callExpressionHandlerHelperATF(node.callee.object.name,
						node.callee.property.name, state, ancestors);

			}
			else if (node.callee.object.type == "NewExpression") { 
				if (node.callee.object.callee.type == "Identifier" ) {
				
					_callExpressionHandlerHelperATF(node.callee.object.callee.name,
							node.callee.property.name, state, ancestors);

				}
				else if (node.callee.object.callee.type == "MemberExpression" &&
						node.callee.object.callee.object.type == "Identifier" &&
						node.callee.object.callee.property.type == "Identifier") {
					// This expression should be <scope>.<Class>
					
					var calleeName = node.callee.object.callee.object.name + "." + 
						node.callee.object.callee.property.name;
					_callExpressionHandlerHelperATF(calleeName,
							node.callee.property.name, state, ancestors);
				}
			}
		}
	}
	catch (e) {
		gs.error("Error in callExpressionHandlerATF: " + e + ". Node: " + JSON.stringify(node));
	}
}

function assignmentExpressionHandlerATF (node, state, ancestors) {
	try {
		
		var detectedClass = 0;
		if (node.type == "AssignmentExpression" &&
			node.operator == "=" &&
			node.right.type == "Identifier" &&
			node.left.type == "Identifier") {
			
			detectedClass = _getTargetedClass(node.right.name, state);
			
		}
		
		if (detectedClass) {
			_insertClassVariable(node.left.name, detectedClass, state, ancestors);
		}
		
		
	} catch (e) {
		gs.error("Error in assignmentExpressionHandlerATF. " + e);
	}
}


//
// Utility methods
//

function _callExpressionHandlerHelper (class_name, caller_name, function_name, state, ancestors) {
	
	if (class_name == "gs") {
		if (function_name == "info" ||
			function_name == "warn" ||
			function_name == "error") {
			
			state.stats.LogCallCount++;
			gs.debug("Found GlideSystem logging. " + caller_name + "." + function_name);
			
		}
		else if (function_name == "debug") {
			
			state.stats.DebugCallCount++;
			gs.debug("Found GlideSystem debug. " + caller_name + "." + function_name);
			
		}
		else if (function_name == "log") {
			
			state.stats.GlobalLogCallCount++;
			gs.debug("Found GlideSystem global log. " + caller_name + "." + function_name);
			
		}
	}
	else if (class_name == "global.GSLog") {
		if (function_name == "info" ||
			function_name == "warn" ||
			function_name == "error" ||
			function_name == "logInfo" ||
			function_name == "logNotice" ||
			function_name == "logWarning" ||
			function_name == "logErr" ||
			function_name == "logCrit" ||
			function_name == "logAlert" ||
			function_name == "logEmerg") {
			
			state.stats.LogCallCount++;
			gs.debug("Found GSLog logging. " + caller_name + "." + function_name);
			
		}
		else if (function_name == "logDebug") {
			
			state.stats.DebugCallCount++;
			gs.debug("Found GSLog debug. " + caller_name + "." + function_name);
			
		}
	}
	
}

function _callExpressionHandlerHelperATF (caller_name, function_name, state, ancestors) {
	
	// Record how many times a tracked Script Include method is called by ATF
	
	/*
		state.targets.methods[methodName]
			Holds the method names found in all targeted Script Includes
			Format of methodName = <scope>.<Class>.<function_property> 
	*/
	
	
	//gs.debug("Found a scripted TEST CALL: " + caller_name + "." + function_name);
	
	// First, assume caller_name is the class being tested, or we are the "global" level of current scope, i.e. 
	// there is no caller_name
	var assumedMethodName = caller_name;
	
	if (!caller_name) {
		// This is a naked function call, which implies we are at the "global" level of the current scope
		assumedMethodName = state.CurrentScope;
	}
	else if (assumedMethodName.indexOf(".") == -1) {
		// Add in the implied scope prefix
		assumedMethodName = state.CurrentScope + "." + assumedMethodName;
		
	}
	assumedMethodName = assumedMethodName + "." + function_name;
	if (state.targets.methods[assumedMethodName] !== undefined) {
		gs.debug("Found a TARGETED scripted TEST CALL: " + assumedMethodName);
		state.targets.methods[assumedMethodName]++; // Increments the number of calls to this method made by ATF
		return;
	}
	
	// if we are here, it is possible that the caller_name was an explicit scope for a function at the 
	// global level of that scope, i.e. <scope>.<function>, or it is a variable. Try the scope theory
	if (caller_name) {
		assumedMethodName = caller_name + "." + function_name;
		if (state.targets.methods[assumedMethodName] !== undefined) {
			gs.debug("Found a TARGETED scripted TEST CALL: " + assumedMethodName);
			state.targets.methods[assumedMethodName]++; // Increments the number of calls to this method made by ATF
			return;
		}
	}
	
	// Now assume the caller is a variable name
	for (var i = state.function_depth; i>= 0; i--) {
		if (state.variables[i][caller_name] !== undefined) {
			var className = state.variables[i][caller_name];
			
			// Append the scope if it is implied in the call semantics (i.e., if it is missing)
			if (className.indexOf(".") == -1) {
				gs.error("PROGRAM ERROR - Every class stored should be fully qualified");
				className = state.CurrentScope + "." + className;
			}
			
			var fullName = className + "." + function_name;
			
			gs.debug("Found a TARGETED scripted TEST CALL: " + fullName);
			if (state.targets.methods[fullName] !== undefined) {
				state.targets.methods[fullName]++; // Increments the number of calls to this method made by ATF
			}
		}
	}
	
}

function _getTrackedClass (object_name, state) {
	// object_name could be a class name, a fully qualified class name (<scope>.<Class>) or a variable name.
	// If it is a class name (that doesn't need to be qualified, like GlideSystem), and is in ]
	// the trackedClasses object, it is also the tracked class name.
	// If it a class name that should be qualified with a scope, add the local scope.
	// If it is a variable, we must look to see if that variable is referencing a tracked class.
	// If so, return that tracked class.
	// Returns null if object is not an instantiation of a tracked class, which also could mean it is not 
	// yet initialized to anything.
	if (trackedClasses[object_name])
		return object_name;

	if (object_name.indexOf(".") == -1) {
		// Trying adding in the implied scope prefix
		var qualifedObjectName = state.CurrentScope + "." + object_name;
		if (trackedClasses[qualifedObjectName])
			return qualifedObjectName;
	}
	
	for (var i = state.function_depth; i >= 0; i--) {
		if (state.variables[i][object_name] !== undefined) {
			return state.variables[i][object_name];
		}
	}

	return null;
}

function _getTargetedClass (object_name, state) {
	// object_name could be a class name or a variable name.
	// If it is a class name, and is in the list of tracked Script Includes
	// it is also the tracked class name.
	// If it is a variable, we must look to see if that variable is referencing a tracked class.
	// If so, return that tracked class.
	// Returns null if object is not an instantiation of a tracked class, which also could mean it is not 
	// yet initialized to anything.
	
	/*
		this.state.targets.classes.<className>
			Holds fully qualified class names, i.e. <scope>.<Class>	
	*/
	
	
	
	// First, assume object_name is the class
	var assumedClassName = object_name;
	if (assumedClassName.indexOf(".") == -1) {
		// Add in the implied scope prefix
		assumedClassName = state.CurrentScope + "." + assumedClassName;
		
	}
	if (state.targets.classes[assumedClassName] !== undefined)
		return assumedClassName;
	
	// Now assume it is a variable. See if it was initialized to a targeted class
	// If so, return that class
	for (var i = state.function_depth; i >= 0; i--) {
		if (state.variables[i][object_name] !== undefined) {
			return state.variables[i][object_name];
		}
	}

	return null;
}

function _getClassOfMethod (object_name, state) {
	// This should only be called for an object that has just had one of its function properties executed.
	// Therefore, object_name could be a class name or a variable name
	// If it is a variable, it must have already been initialized to a class since we are calling a method on it,
	// so look for it's class in the function tracker
	// If it is a class, 
	
	for (var i = state.function_depth; i >= 0; i--) {
		if (state.variables[i][object_name] !== undefined) {
			return state.variables[i][object_name];
		}
	}

	return null;
}

function _isThisObjectThisClass (object_name, class_name, state) {
	
	if (object_name == class_name)
		return true;
	
	// Our version of javascript has variables scoped by function. A variable declared in function A
	// will be seen by a function B nested inside of function A, unless of course it is overriden by a 
	// variable local to A. Function depth 0 is global scope, and those global variables are seen by everyone.
	// This will look for a variable up the nested function chain.
	for (var i = state.function_depth; i >= 0; i--) {
		if (state.variables[i][object_name] !== undefined) {
			return state.variables[state.function_depth][object_name] == class_name;
		}
	}
	
	return false;
}

function _insertClassVariable (object_name, class_name, state, ancestors) {
	
	state.variables[state.function_depth][object_name] = class_name;
	
	gs.debug("Variable Declaration for \"" + class_name + "\" in " +  _findContainingFunctionName(ancestors) +
	"." + object_name + ", function depth " + state.function_depth);
}

function _findContainingFunctionName (ancestors) {
	// Walk back up the ansestor nodes looking for a FunctionDeclaration or a FunctionExpression,
	// whichever comes first.
	for (var x = ancestors.length - 1; x >= 0; x--) {
		if (!ancestors[x].type) continue;
			if (ancestors[x].type == "FunctionDeclaration") {
			return ancestors[x].id.name;
		}
		else if (ancestors[x].type == "FunctionExpression") {
			// Go back one more to the parent property, a key:value pair.
			// The FunctionExpression is the value. The name is an identier in the key
			if (0 == x) throw "Could not find ancenstor for function identification";
				--x;
			if (ancestors[x].type != "Property")
				return "Unnamed";
			else
				return ancestors[x].key.name;
		}
	}
}

function _fullObjectName(object) {
	
	// Recursively dot walk the complete object name
	try {
	    if (object.type == "Identifier") {
			return object.name;
		}
		if (object.type == "MemberExpression") {
			return _fullObjectName(object.object) + "." + object.property.name;
		}
		return null;
	}
	catch (e) {
		gs.error("_walkObjectName: unexpected syntax, " + e);
	}
}


]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>dave.knight</sys_created_by>
        <sys_created_on>2018-08-06 03:43:03</sys_created_on>
        <sys_customer_update>true</sys_customer_update>
        <sys_id>721d1ebc4f37df40ea338e328110c718</sys_id>
        <sys_mod_count>226</sys_mod_count>
        <sys_name>Main</sys_name>
        <sys_package display_value="Validator" source="x_snc_dk_validator">65ec1ebc4f37df40ea338e328110c714</sys_package>
        <sys_policy>read</sys_policy>
        <sys_replace_on_upgrade>false</sys_replace_on_upgrade>
        <sys_scope display_value="Validator">65ec1ebc4f37df40ea338e328110c714</sys_scope>
        <sys_update_name>sys_script_include_721d1ebc4f37df40ea338e328110c718</sys_update_name>
        <sys_updated_by>dave.knight</sys_updated_by>
        <sys_updated_on>2018-10-03 16:02:25</sys_updated_on>
    </sys_script_include>
</record_update>
