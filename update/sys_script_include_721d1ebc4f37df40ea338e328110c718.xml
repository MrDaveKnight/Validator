<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>public</access>
        <active>true</active>
        <api_name>x_snc_dk_validator.Main</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <name>Main</name>
        <script><![CDATA[var Main = Class.create();

/*

Standard Usage - Use "Run" modules in Validator application

Scripted Usage
__________________

To scan an accelerator packaged in Update Sets

    var results = new GlideRecord("x_snc_dk_valid_res_metrics");
    var validator = new x_snc_dk_validator.Main(results, "Scan description");
    validator.processPackagedAppFiles("update_set", "state=complete");
    validator.saveResults();

To scan all Application Files (which includes Workflow Activities and Variables) on an instance

    var results = new GlideRecord("x_snc_dk_valid_res_metrics");
    var validator = new x_snc_dk_validator.Main(results, "Scan description");
    validator.processAllApplicationFiles();
    validator.saveResults();

Terminology
--------------
There are two types of "Class" in this program
    #1 The Class created by a Script Include
    #2 The Class or type of a table (sys_class_name)

This Main script uses definition #2 exclusively. The Scanner library uses definition #1. 

Design Notes
--------------

* Logging Statistics

During "targeted" script scanning, detect all variable declarations and assignments of "tracked" classes, 
and their function nesting depth so we can deal with function scoping and variable overrides, 
and record the "Class" of object those variables represent. A tracked class is one that relates to logging.
A targeted script will be in the package(s) identified during Main initialization. 

The Class name saved will be fully qualified, i.e. <scope>.<Class>. Save this name in state.variables.<function_depth>.<variable_name> = <scope>.<class>. This information will be used to identify method calls to tracked objects
such as "gs" or "GSLog". The global scope is "global". 

* White Box Test Statistics

During targeted script scanning, detect all function declarations, and record their fully qualified method name,
i.e. <scope>.<Class>.<function_property>. Save this information in state.targets.methods.<method>

The method names in state.targets.methods will indicate what is eligable for a scripted ATF test.
The value of each state.targets.methods.<method_name> will be the number of ATF calls to that method.

During testCoverage scanning, detect all variable declarations and assignments, at their function nesting
depth, and record the Class of object those variables represent. This will be a fully qualified class, 
i.e. <scope>.<Class_name>. Save this information in 
state.variables.<function_depth>.<variable_name> = <scope>.<Class>. This information will be used to 
identify calls to targeted functions. The call is identified as <scope>.<Class>.<function>. If
the scope is not used as a class prefix in the ATF source code, add the implied scope, 
which is the scope of the ATF test.

*/

// These are the "classes" we are interested in tracking in order to gather call statistics
// other than ATF. for now, it is classes associated with logging. TODO make it configurable.
// Side Note - all classes (script includes actually) are targeted when processing ATF scripts. 
// We want to track all calls, to any Script Include method, since most will be executing tests.
// This data structure is for everything except ATF.
trackedClasses = {
    gs: 1
};
trackedClasses["global.GSLog"] = 1; // The dot causes issues with static initialization



Main.prototype = {

    // Types of ATF test
    CODELESS: "codeless",
    SCRIPTED: "scripted",

    initialize: function (results, desc) {
        // results must be null or a x_snc_dk_valid_res_metrics GlideRecord


        this.activeTargetedAtfSteps = {};

        // For progress calculations
        this.itemsToProcess = 0;
        this.itemsProcessed = 0;
        this.progressUpdateMilestone = 0;
        this.progressUpdatePeriod = 3000; // 3 seconds

        // Stats will be passed around to a variety of classes (modules) for processing.
        // Capitalized variables will be output eventually.
        this.stats = {

            startedAt: gs.hoursAgo(0),
            checksum: 0, // Accelerator package checksum
			description: desc,

            // Stats generated by RegEx scans over script
            CodeCharCount: 0,
            CommentCharCount: 0,
            NoCommentFileCount: 0,

            // Atf 
            NumberOfActiveCodelessTestSteps: 0,
            NumberOfActiveScriptedTestSteps: 0,

            // Models (dynamically defined tables like Catalog Items for example) with 
            // scripted variables (the dynamic fields for the model) 
            // that actually have script in them. Just because a scripted field
            // is declared, it doesn't mean it actually has script in it. 
            // We want to track the number of models that actually have some
            // script associated with them.
            modelsWithScript: {
                // This needs to be in sync with switch statement in Inspector.examineVariable!  
                wf_activity: {}, // Only this guy is being used at the moment
                sys_hub_action_type_definition: {} // This is not being used at the moment
            },

            // Counts of active records in all application file classes
            inventory: {}
        };


        // State will be uses during script scanning. The AST walker scripts expect
        // a "state" parameter. It will be passed down into the Scanner class.
        // It collects stats related to script scanning, and also holds scan state information.
        this.state = {

            status: "Initialization",
            progress: 0.0,
            resultsGR: results, // Null, or a x_snc_dk_valid_res_metrics GlideRecord

            // Stats generated by AST scan
            // NOTICE! Any of the helpers in this file that collect stats must have that stat initialized
            // in this state object!
            stats: {
                ScriptSize: 0, // The number of nodes in the script's syntax tree
                LinesOfCode: 0,  // Javascript statements, variable declarations, assignment expressions and function calls
                DebugCallCount: 0,
                LogCallCount: 0,
                GlobalLogCallCount: 0,

                // Statement counts
                // Format: <AST Parser Node Type>Count
                BlockStatementCount: 0,
                ExpressionStatementCount: 0,
                IfStatementCount: 0,
                LabeledStatementCount: 0,
                BreakStatementCount: 0,
                ContinueStatementCount: 0,
                WithStatementCount: 0,
                SwitchStatementCount: 0,
                ReturnStatementCount: 0,
                ThrowStatementCount: 0,
                TryStatementCount: 0,
                WhileStatementCount: 0,
                DoWhileStatementCount: 0,
                ForStatementCount: 0,
                ForOfStatementCount: 0,
                LetStatementCount: 0,
                DebuggerStatementCount: 0,

                FounctionDeclarationCount: 0,
                FunctionExpressionCount: 0,
                VariableDeclaratorCount: 0,

                inventory: {},      // Script metrics for each table class
                inventoryIndex: ""  // Set this before each script scan
            },
            targets: {
                files: {
                    ATFTestSteps: {},
                },
                classes: {},
                methods: {}
            },
            processingPackages: false, // As opposed to scanning everything on the box
            query: "", // Package filter
            format: "", // Type of package
            dumpTree: false,
            has_script: false,  // Reset this before each AST scan
            variables: {},
            block_scope: {},
            function_depth: 0,
            block_depth: 0,
            currentScope: ""
        };

        this.state.variables[0] = {}; // CHG1
        this.state.block_scope[0] = {};

        if (this.state.resultsGR) {
            this.state.resultsGR.status = this.state.status;
            this.state.resultsGR.started = this.stats.startedAt;
            this.state.resultsGR.progress = 0.0;
            //this.state.resultsGR.setWorkflow(false);
            this.state.resultsGR.update();
        }

        // TODO Do property lookup for this
        //    this.state.dumpTree = true;

    },

    saveResults: function () {

        new Output(this.stats, this.state).run();

    },

    processAllApplicationFiles: function () {


        // AST walk handlers
        var scriptHandlers = {
            FunctionDeclaration: Scanner.statementHandler,
            FunctionExpression: Scanner.statementHandler,
            CallExpression: Scanner.callExpressionHandler,
            AssignmentExpression: Scanner.assignmentExpressionHandler,
            MemberExpression: Scanner.memberExpressionHandler,
            VariableDeclarator: Scanner.variableDeclaratorHandler,
            ExpressionStatement: Scanner.statementHandler,
            BlockStatement: Scanner.statementHandler,
            IfStatement: Scanner.statementHandler,
            LabeledStatement: Scanner.statementHandler,
            BreakStatement: Scanner.statementHandler,
            ContinueStatement: Scanner.statementHandler,
            WithStatement: Scanner.statementHandler,
            SwitchStatement: Scanner.statementHandler,
            ReturnStatement: Scanner.statementHandler,
            ThrowStatement: Scanner.statementHandler,
            TryStatement: Scanner.tryStatementHandler,
            WhileStatement: Scanner.statementHandler,
            DoWhileStatement: Scanner.statementHandler,
            ForStatement: Scanner.statementHandler,
            ForOfStatement: Scanner.statementHandler,
            LetStatement: Scanner.statementHandler,
            DebuggerStatement: Scanner.statementHandler
        };


        var limiter = 0;
        var theLimit = 10000;

        //
        // Phase 1
        //
        // Process all Application File descendant records
        //

        for (var table_class_name in Spider.appFiles) {

            if (!gs.tableExists(table_class_name)) {
                gs.error("processAllApplicationFiles: Spider identified a non-existent table, " + table_class_name + ". Ignoring.");
                continue;
            }

            if (Spider.appFiles[table_class_name].is_restricted == true) {
                continue; // TODO Can we do something about this?
            }

            if (++limiter > theLimit)
                break;

            var af = new GlideRecord(table_class_name);
            af.addActiveQuery();  // Only interested in active records
            af.query();
            var limit = 0;  // for test
            while (af.next()) {

                // Only process records that are in this class, as opposed to descendents of this class.
                // If the application file is a decendent of the class we are processing, 
                // we will get around to looking at it when we scan it's class.
                if (af.sys_class_name != table_class_name)
                    continue;

                Inspector.examineRecord(this.stats, this.state, af, table_class_name, Spider.appFiles[table_class_name].name_field, null, false);
            }
        }

        //
        // Phase 2
        //
        // Workflow Activities
        //
        // This is a special case. Workflow activity definitions are App Files, but 
        // Workflow Activities themselves are not. Packaging is handled with the workflow itself, 
        // which is the app file.
        //
        // Only collecting record counts. 
        // Iterate over all workflow activities that are associated with a published workflow. 

        limiter = 0;
        var wfa = new GlideRecord("wf_activity");
        wfa.query();
        while (wfa.next()) {

            if (++limiter > theLimit)
                break;

            if (!Inspector.isActive(wfa, "wf_activity")) {
                continue;
            }
            Inspector.examineWorkflowActivity(this.stats, this.state,
                wfa.name.toString(), wfa.workflow_version.workflow.sys_scope.toString());
        }

        //
        // Phase 3
        //
        // Process Variables
        //
        // Only collecting script metrics here!
        // Iterate over all variable "values". The ones that are actually a script
        // are identified by the Spider.scriptVariables object and will be deemed
        // as "Under Inspection".
        var v = new GlideRecord("sys_variable_value");
        v.query();

        limiter = 0;
        theLimit = 1000;

        while (v.next()) {

            if (++limiter > theLimit)
                break;

            var var_dictionary_id = v.variable.toString();
            if (!Inspector.isVariableUnderInspection(var_dictionary_id)) {
                continue;
            }
            if (!Inspector.isActive(v, "sys_variable_value")) {
                continue;
            }

            var script_value = v.value.toString(); // To be under inspection, must be a script
            var document_key = v.document_key.toString();
            var var_id = v.sys_id.toString();

            Inspector.examineVariable(this.stats, this.state, script_value,
                document_key, var_dictionary_id, var_id);
        }
    },


    _scanTestCoverage: function () {


        if (!this.state.processingPackages) {
            gs.error("Usage error: You must define a package for test coverage analysis.");
            return;
        }

        // First, collect the ids of all active test scripts that were identified by the targeted
        // updates/pluggins. Some may not have been active. Default their type to codeless, even
        // though some may be scrpted. We will find the scripted ones shortly.
        var atfStepsGR = new GlideRecord("sys_atf_step");
        atfStepsGR.addQuery("active", true);
        atfStepsGR.addQuery("test.active", true);
        // Since I'm not sure how big the sys_id string can be before blowing up a GlideRecord
        // encodedQuery, I'm going to simply loop through instead of setting up a GlideAggregate.
        atfStepsGR.query();
        while (atfStepsGR.next()) {

            if (!this.state.targets.files.ATFTestSteps[atfStepsGR.sys_id])
                continue;

            this.activeTargetedAtfSteps[atfStepsGR.sys_id] = this.CODELESS; // Default

        }

        // Next, scan white-box (scripted) tests, and update the state of those steps in the active
        // targeted list. We want to differentiate between black-box codeless and white-box scripted 
        // tests

        // AST walk handlers
        var atfScriptHandlers = {
            CallExpression: Scanner.callExpressionHandlerATF,
            VariableDeclarator: Scanner.variableDeclaratorHandlerATF,
            AssignmentExpression: Scanner.assignmentExpressionHandlerATF
        };

        // Find all ATF configuration input variables of script type (script and script_plain currently.)
        var atfScriptTypesGR = new GlideRecord("atf_input_variable");
        atfScriptTypesGR.addActiveQuery();
        atfScriptTypesGR.addEncodedQuery("internal_typeLIKEscript");
        atfScriptTypesGR.query();
        while (atfScriptTypesGR.next()) {


            this.state.currentScope = "global";
            var scopeGR = new GlideRecord("sys_scope");
            if (scopeGR.get(atfScriptTypesGR.sys_scope)) {
                this.state.currentScope = scopeGR.scope.toString();
            }

            // TEST
            // this.state.currentScope = "x_snc_dk_validator";

            // Find actual test step input variables that are configured as one of these script types, and scan ...
            var atfScriptsGR = new GlideRecord("sys_variable_value");
            atfScriptsGR.addQuery("document", "sys_atf_step");
            atfScriptsGR.addQuery("variable", atfScriptTypesGR.sys_id);
            // atfScriptsGR.addQuery("document_key", "6bac16114f771380ea338e328110c7c5"); // TEST STEP
            atfScriptsGR.query();
            while (atfScriptsGR.next()) {

                // document_key is the sys_id of the test step, given that the document is a sys_atf_step.
                if (!this.activeTargetedAtfSteps[atfScriptsGR.document_key])
                    continue;

                this.activeTargetedAtfSteps[atfScriptsGR.document_key] = this.SCRIPTED; // changing from codeless

                // The script is in the value field of an input variable. Since there is no name
                // for the input variable, we will track it by GUID
                this._scanAtfScript(atfScriptsGR, "document_key", "value", atfScriptHandlers);
            }
        }

        for (var i in this.activeTargetedAtfSteps) {

            if (this.activeTargetedAtfSteps[i] == this.SCRIPTED)
                this.stats.NumberOfActiveScriptedTestSteps++;
            else
                this.stats.NumberOfActiveCodelessTestSteps++;
        }
    },



    _scanAtfScript: function (gr, name_field, script_field, ast_walk_handlers) {
        try {

            var code = gr[script_field].toString();

            if (code.length <= 0) {
                gs.info("No script in " + gr[name_field]);
                return;
            }

            var tree = x_snc_dk_acorn.ASTree.parse(code);  // Make the Abstract Syntax Tree

            // For dev purposes
            //if (this.state.dumpTree) {
            //	gs.info(JSON.stringify(tree).replace(/,/g, '\n'));
            //}
            x_snc_dk_acorn.ASTree.walk(tree, ast_walk_handlers, null, this.state);

            // Be explicit (probably not necessary)
            code = 0;
            tree = 0;
        }
        catch (e) {
            gs.error("_scanAtfScript: MAJOR processing exception on " + gr[name_field] + ". " + e);
            // break;
        }
    },



    processPackagedAppFiles: function (format, query) {

        this.state.processingPackages = true;
        this.state.format = format;
        this.state.query = query;

        var packageRecordName = "";
        switch (format) {
            case "remote_update_set":
                packageRecordName = "sys_remote_update_set";
                break;
            case "update_set":
                packageRecordName = "sys_update_set";
                break;
            case "scope":
                packageRecordName = "sys_scope";
                break;
            case "plugin":
                packageRecordName = "v_plugin";
                break;
            default:
                gs.error("Invalid accelerator packaging format. Aborting!");
                throw "exit";
        }

        try {

            // Get a count of all the packaged items we will have to process for the progress bar
            var gr = new GlideRecord(packageRecordName);
            gr.addEncodedQuery(query);
            gr.query();
            while (gr.next()) {
                switch (format) {
                    case "remote_update_set":
                    case "update_set":
                        var updateCount = new GlideAggregate("sys_update_xml");
                        updateCount.addAggregate("COUNT");
                        updateCount.addQuery("update_set", gr.sys_id);
						updateCount.addQuery("action", "INSERT_OR_UPDATE");
                        updateCount.query();
                        if (updateCount.next()) {
                            this.itemsToProcess += parseInt(updateCount.getAggregate("COUNT"));
                        }
                        break;
                    case "scope":
                        this._processScope(gr);
                        break;
                    case "plugin":
                        this._processPlugin(gr);
                        break;
                    default:
                        gs.error("Invalid accelerator packaging format. Ignoring!");
                }
            }
			
			// 
            // Transition to Running state
            //

            if (this.state.resultsGR) {
                this.state.status = "Running";
                this.state.resultsGR.status = this.state.status;
                //this.state.resultsGR.setWorkflow(false);
                this.state.resultsGR.update();
            }

            gr.initialize();
            gr.addEncodedQuery(query);
            gr.orderBy("sys_id"); // This is for the checksum calculation
            gr.query();
            while (gr.next()) {
                switch (format) {
                    case "remote_update_set":
                    case "update_set":
                        this._processUpdateSet(gr.sys_id.toString());
                        break;
                    case "scope":
                        this._processScope(gr);
                        break;
                    case "plugin":
                        this._processPlugin(gr);
                        break;
                    default:
                        gs.error("Invalid accelerator packaging format. Ignoring!");
                }
            }
        }
        catch (e) {
            gs.error("processPackagedAppFiles: Unhandled exception during package scans. Aborting. Msg: " + e);
            throw "exit";
        }

        try {
            this._scanTestCoverage();
        }
        catch (e) {
            gs.error("processPackagedAppFiles: Unhandled exception during ATF scans. Aborting. Msg: " + e);
            throw "exit";
        }
		
		// TODO - Add the Pass Fail logic
        this.state.status = "Fail"; 
    },

    _processUpdateSet: function (update_set_id) {
        var gr = new GlideRecord("sys_update_xml");
        gr.addQuery("update_set", update_set_id);
        gr.addQuery("action", "INSERT_OR_UPDATE");
        gr.orderBy("sys_id"); // This is for checksum calculation
        gr.query();
        while (gr.next()) {

            var payload = gr.payload.toString();

            // This is a cumulative signature across all payloads. Ensure they are 
            // always ordered consistently! 
            this.stats.checksum = Checksum.crc32(payload, this.stats.checksum);

            var fileType = gr.type.toString();
            if ("Workflow" == fileType) {
                // TODO: this is involved!
                // This payload contains a variety of record meta, and depends on other meta info
                // to convert the XML to JSON, and walk it to find information about
                // the values, and then go out to definitions for those values in different records since
                // that is the only way to figure out what they are actually for. That is the only way to determine what
                // each value actually is (script for an if statement, a user approval, a script activity,...)

                // Format of a Workflow update payload
                // -----------------------------------------
                // All of the elements of a workflow are included in the update set
                // associated with a wf_workflow_version application file:
                //  - wf_workflow_version
                //  - wf_workflow  
                //  - wf_condition (one for workflow, and one for each activity)
                //  - wf_activity
                //  - sys_variable_value 
                //  - wf_transition
                //  - wf_estimated_runtime_config
                //
                // There are many sets of a wf_activity and its associated sys_variable_values.
                // They are all in order. The values will follow the activity immediately. 
                // Grouping is relevant because we count how many activities have script.
                // Even though we know apriori if an activity has scripted variables,
                // we don't know if they actually have script until we scan them. They
                // may be empty or defaulted to nothing but comments. Therefore, we have
                // to scan all of the variables assocated with an activity as a 
                // unit to determine if the activity is actually scripted.
                //
                // Inspection processing
                // -----------------------------------------
                //  - Each wf_activity needs to be accounted for
                //  - Each scripted sys_variable_value needs to be scanned for metrics
                //  - A wf_activity is active if it's workflow is "published"
                //  - A wf_activity is scripted if one of its variables is scripted, AND
                //    there is actually some live script in it
                //
                // We will use XMLDocument2 to parse the xml. It is good at iterating
                // over a particular node type. Iterating of variables for a particular
                // activity, not so much. Therefore, we will process in two phases.
                // The first will go through all activities, logging each one that is found. 
                // The second will go through all variables, scanning for metrics,
                // and updating the activity log when a script is found. 
                //
                // Note that there appears to be a bug in the update set payload 
                // generator? I see duplicates for variables in many examples
                // Se, we can't trust this stuff. Better track info for each sys_id
                // in a hash object.
                //
                //
                // By definition, the workflow, activities and variables in this update set
                // record are related. This makes checking for active simple. 

                var payloadXML = new XMLDocument2();
                payloadXML.parseXML(payload);

                // Active check
                if (payloadXML.getNodeText("/record_update/wf_workflow_version/published") != true)
                    continue;

                var scope = payloadXML.getNodeText("/record_update/wf_workflow/sys_scope");

                var currentNode = payloadXML.getFirstNode("/record_update/wf_activity/sys_id");
                while (currentNode) {

                    Inspector.examineWorkflowActivity(this.stats, this.state, currentNode.getNodeName(), scope);
                    currentNode = payloadXML.getNextNode(currentNode);
                }

                currentNode = payloadXML.getFirstNode("/record_update/sys_variable_value");
                while (currentNode) {

                    var iter = currentNode.getChildNodeIterator();
                    var n = 0;
                    var isScript = false;
                    var scriptString = "";
                    var documentKey = "";
                    var varDictionaryId = "";
                    var varId = "";
                    while (iter.hasNext()) {
                        n = iter.next();
                        if (n.getNodeName() == "variable") {
                            if (Inspector.isVariableUnderInspection(n.getTextContent())) {
                                isScript = true;
                                varDictionaryId = n.getTextContent();
                            }
                        }
                        else if (n.getNodeName() == "sys_id") {
                            varId = n.getTextContent();
                        }
                        else if (n.getNodeName() == "document_key") {
                            documentKey = n.getTextContent();
                        }
                        else if (n.getNodeName() == "value") {
                            scriptString = n.getTextContent();
                        }
                    }
                    if (isScript) {
                        Inspector.examineVariable(this.stats, this.state, scriptString,
                            documentKey, varDictionaryId, varId);
                    }

                    currentNode = payloadXML.getNextNode(currentNode);
                }

            }
            else {

                Inspector.examinePayload(this.stats, this.state, payload);
            }

            this._checkProgress();
        }
    },

    _checkProgress: function () {

        if (this.itemsToProcess <= 0)
            return;

        this.itemsProcessed++;

        var now = new GlideDateTime(gs.hoursAgo(0)).getNumericValue();
        if (now > this.progressUpdateMilestone) {

            this.state.resultsGR.progress = (100.0 * this.itemsProcessed / this.itemsToProcess).toFixed(0);
            //this.state.resultsGR.setWorkflow(false);
            this.state.resultsGR.update();

            this.progressUpdateMilestone = now + this.progressUpdatePeriod;
        }
    },

    _processPlugin: function (pluginGR) {
        // TODO - FIXME
        // This needs to be updated and tested

        var appFileGR = new GlideRecord("sys_metadata");

        //
        // Copied from "Plugin Files" Relationship
        //

        // A plugin is either global, or a scoped app.
        // In either case, the Application File's "Package" field will reference
        // a Package record. If Global, the Package record will actually be a 
        // get the package sys_id
        var packageID = "-1";
        var scopeName = !pluginGR.scope.nil() ? pluginGR.scope.toString() : 'global';

        // check if the source is actually a scoped application
        // if so the packageID is the scopeID
        var scope = new GlideRecord('sys_scope');
        if (scopeName !== 'global' && scope.get('scope', scopeName)) {
            packageID = scope.getUniqueValue();
            var files = new GlideRecord('sys_metadata');
            files.addQuery('sys_package', packageID);
            files.addQuery('sys_customer_update', true);
            files.query();
            // exclude customer files if any
            var customerFileIds = new global.UpdateVersionAPI().getCustomerFileIds(files);
            if (customerFileIds.length > 0)
                appFileGR.addQuery('sys_id', 'NOT IN', customerFileIds);
        } else {
            var plugin = new GlideRecord("sys_plugins");
            if (plugin.get("source", pluginGR.id.toString()))
                packageID = plugin.getUniqueValue();
        }

        appFileGR.addQuery("sys_package", packageID);
        // TODO add activity query
        appFileGR.query();
        while (appFileGR.next()) {

            var api = null;
            var fileType = appFileGR.sys_class_name.toString();
            if (fileType == "Script Include" && appFileGR.api_name)
                api = appFileGR.api_name.toString();

            // TODO active checks for special cases
            if (gr.sys_class_name == "wf_activity") {
                if (wfa.workflow_version) {
                    if (wfa.workflow_version.published) {
                        this.stats.inventory.wf_activity.count++;
                        if (!wfa.workflow_version.workflow ||
                            !wfa.workflow_version.workflow.sys_scope ||
                            wfa.workflow_version.workflow.sys_scope == "global") {
                            this.stats.inventory.wf_activity.global_count++;
                        }
                    }
                }
            }

        }
    },

    _processScope: function (scopeGR) {
        // TODO - FIXME
        // This needs to be updated and tested

        var appFileGR = new GlideRecord("sys_metadata");
        appFileGR.addQuery("sys_scope", scopeGR.sys_id.toString());
        appFileGR.query();
        while (appFileGR.next()) {

            var api = null;
            var fileType = appFileGR.sys_class_name.toString();
            if (fileType == "Script Include" && appFileGR.api_name)
                api = appFileGR.api_name.toString();

        }
    },

    type: 'Main'
};





]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>dave.knight</sys_created_by>
        <sys_created_on>2018-08-06 03:43:03</sys_created_on>
        <sys_customer_update>true</sys_customer_update>
        <sys_id>721d1ebc4f37df40ea338e328110c718</sys_id>
        <sys_mod_count>314</sys_mod_count>
        <sys_name>Main</sys_name>
        <sys_package display_value="Validator" source="x_snc_dk_validator">65ec1ebc4f37df40ea338e328110c714</sys_package>
        <sys_policy/>
        <sys_replace_on_upgrade>false</sys_replace_on_upgrade>
        <sys_scope display_value="Validator">65ec1ebc4f37df40ea338e328110c714</sys_scope>
        <sys_update_name>sys_script_include_721d1ebc4f37df40ea338e328110c718</sys_update_name>
        <sys_updated_by>dave.knight</sys_updated_by>
        <sys_updated_on>2018-10-31 17:23:06</sys_updated_on>
    </sys_script_include>
</record_update>
